

>ä¸‹è½½ç»ƒä¹ å†Œé¢˜é¢ä»¥åŠæƒ³è¦æ‹‰åˆ°æœ¬åœ°è·‘ä»£ç å¯ä»¥å» [CPlus ä»“åº“](https://github.com/ceilf6/CPlusPlus)
æˆ–è€…ç»ˆç«¯è¾“å…¥å‘½ä»¤
```
git clone https://github.com/ceilf6/CPlusPlus
```
> å¦‚æœç¿»ä¸äº†å¢™ä¹Ÿå¯ä»¥ç”¨å›½å†…å¹³æ›¿ [CPlus ä»“åº“ï¼ˆå›½å†…ï¼‰](https://gitee.com/ceilf6/SHU_CPlus)
# README
> âš ï¸ ç”±äºæ—¶é—´ç´§è¿«ï¼Œè¿™æ˜¯æˆ‘åœ¨å›æ ¡åä¸€å‘¨å†…åŒæ—¶å¤ä¹ å¤šé—¨è¯¾ç¨‹ã€æŠ½ç©ºå®Œæˆçš„ï¼Œå¦‚æœ‰ä¸åˆç†ä¹‹å¤„ï¼Œæ¬¢è¿éšæ—¶äº¤æµï¼Œæˆ–ç›´æ¥åœ¨ä»“åº“æ Issue / PRã€‚
```
## ğŸ§  å…³äºç®—æ³•çš„ä¸€äº›æµ…è§ï¼ˆå¿«é€Ÿå…¥é—¨å‘ï¼‰

ç®—æ³•æ˜¯åŸºäºè®¡ç®—æœºæ€æƒ³å¯¹æ•°æ®è¿›è¡Œç®¡ç†å’Œé«˜æ•ˆæ“ä½œçš„è‰ºæœ¯ã€‚å®ƒå¾€å¾€æºäºæˆ‘ä»¬å¯¹é—®é¢˜ç»“æ„çš„è§‚å¯Ÿå’ŒæŠ½è±¡ï¼š

- **åˆ†æ²»æ€æƒ³** â†’ å‚¬ç”Ÿäº†å½’å¹¶æ’åºã€å¿«é€Ÿæ’åºç­‰ï¼›
- **æ ‘å½¢ç»“æ„** â†’ å‘å±•å‡ºäº†æ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDFSï¼‰ã€å­—å…¸æ ‘ã€çº¿æ®µæ ‘ç­‰ï¼›
- **æ‡’æ›´æ–°** â†’ è§£å†³äº†é«˜é¢‘åŠ¨æ€åŒºé—´ä¿®æ”¹çš„é—®é¢˜ï¼ˆå¦‚çº¿æ®µæ ‘æ‡’æ ‡è®°ï¼‰ï¼›
- **é‡å å­é—®é¢˜** â†’ ä¿ƒæˆäº†åŠ¨æ€è§„åˆ’ï¼Œå€ŸåŠ©çŠ¶æ€è½¬ç§» + é€’å½’å›æº¯é™ä½å¤æ‚åº¦ã€‚

ğŸ’¬ é¡ºå¸¦ä¸€æï¼š  
ç®—æ³•æ€æƒ³ä¹Ÿå¹¿æ³›åº”ç”¨äºå…¶ä»–é¢†åŸŸã€‚ä¾‹å¦‚åœ¨å‰ç«¯å¼€å‘ä¸­ï¼Œç†è§£"æ ‘å½¢ç»“æ„"çš„é€»è¾‘ï¼Œå¯ä»¥ï¼š

- æ¸…æ™°æè¿° UI ç»„ä»¶çš„å±‚çº§å…³ç³»ï¼›
- åœ¨"åˆ†å‰èŠ‚ç‚¹"å¤ç”¨å…¬å…±ç»„ä»¶ï¼›
- é€šè¿‡ `props` æ³¨å…¥å·®å¼‚åŒ–é€»è¾‘ï¼Œå®ç°**é«˜åº¦å¤ç”¨**å’Œ**ä½è€¦åˆå·¥ç¨‹**ã€‚

---

## ğŸ¤ ä¸€èµ·è¿›æ­¥ï¼

æ¬¢è¿å„ä½å¤§ä½¬ä¸€èµ·æ¢è®¨ä¸äº¤æµï¼Œäº’ç›¸å­¦ä¹ ï¼ŒæŒç»­æˆé•¿ ğŸš€  
ğŸ‘‰ æœ‰é—®é¢˜éšæ—¶æ Issueï¼Œæˆ–è€…å‘èµ· PRï½

---

> åœ¨åšå®Œç®—æ³•å†Œé¢˜ç›®åæˆ‘å‘ç°æœ¬é—¨è¯¾æ›´åŠ æ³¨é‡å¯¹ C++ åŸºç¡€ç‰¹æ€§çš„æŠŠæ¡ä»¥åŠå·¥ç¨‹åŒ–ä¸­çš„å®‰å…¨å®è·µï¼Œå¯¹åŒå­¦ä»¬åé¢å·¥ä½œæœ‰å¾ˆå¤§å¸®åŠ©
```
# Ex01
```cpp
// ä»“åº“åœ°å€ï¼šhttps://github.com/ceilf6/CPlusPlus

#include <iostream> // å¯¼å…¥è¾“å…¥è¾“å‡ºæ•°æ®æµ
#include <string>

// #include<bits/stdc++.h>
// ä¸Šé¢ä¸¤è¡Œè¿˜å¯ä»¥ç”¨ä¸‡èƒ½å¤´è¿›è¡Œæ›¿æ¢ï¼Œä¼˜ç‚¹æ˜¯ä¸éœ€è¦è®°å¿†å„ä¸ªåŠŸèƒ½éœ€è¦çš„åº“çš„åç§°ï¼Œä½†æ˜¯ç¼ºç‚¹æœ‰ä¸æ˜¯C++çš„æ ‡å‡†å¤´æ–‡ä»¶ã€ç¼–è¯‘é€Ÿåº¦æ…¢

using namespace std; // ä½¿ç”¨stdçš„å‘½åç©ºé—´ï¼ˆä¸ä½¿ç”¨ä¹Ÿå¯ä»¥ï¼Œå°±æ˜¯ä¸‹é¢å¾—ç”¨std::coutã€std::cinï¼Œæ¯”è¾ƒéº»çƒ¦
void bonjour()
{
    cout << "è¾“å…¥æ‚¨çš„åå­—";             // è¾“å…¥
    string name;                        // å®šä¹‰å˜é‡ç±»å‹
    cin >> name;                        // è¾“å…¥
    cout << "bonjour " << name << '\n'; // æ ¼å¼åŒ–è¾“å‡º
}

int main()
{ // ä¸»å‡½æ•°è°ƒç”¨ä¸Šé¢å®šä¹‰çš„åŠŸèƒ½å‡½æ•°å®ç°æ¨¡å—åŒ–åŒºåˆ†ã€ä»£ç çš„æ¾è€¦åˆ
    bonjour();
    return 0;
}
```


# Ex02
```cpp
/*
æ„Ÿè§‰ç®—æ³•è¿™é—¨è¯¾ä¸»è¦çš„éš¾ç‚¹åœ¨äºç†è§£æ³•è¯­é¢˜é¢doge

è¿™é“é¢˜ä¸»è¦çš„æ„æ€æ˜¯åœ¨å‰ä¸€ä¸ªæ–‡ä»¶çš„åŸºç¡€ä¸Šæ·»åŠ ä¸€ä¸ªå¤´æ–‡ä»¶
ç„¶åå°†æ–‡ä»¶å¡«å…¥å¤´æ–‡ä»¶
ä¼šå‘ç°è¯­æ³•é”™è¯¯
å› ä¸ºC++çš„å¤´æ–‡ä»¶æ˜¯ç”¨äºè¢«å¯¼å…¥åˆ°ä½¿ç”¨æ–‡ä»¶ä¸­ä¸ºä½¿ç”¨æ–‡ä»¶è§„èŒƒç±»å‹ã€æšä¸¾ï¼Œå£°æ˜å‡½æ•°ç­‰ç­‰
ï¼ˆæœ‰ç‚¹åƒTSï¼‰
æ‰€ä»¥C++çš„å¤´æ–‡ä»¶æœ¬è´¨è¿˜æ˜¯éœ€è¦ç”¨C++å»å†™ï¼ˆä¹Ÿå¯ä»¥å…¼å®¹ extend "C"ï¼‰
å¦‚æœç”¨è‡ªç„¶è¯­è¨€å°±ä¼šæŠ¥é”™
*/```


# Ex03
```cpp
/*
è¿™é“é¢˜ç›®æ˜¯ç”¨äºè¿›ä¸€æ­¥ç†è§£C++çš„å·¥ç¨‹æ–‡ä»¶æ¶æ„çš„ä»¥åŠC++ä½œä¸ºç¼–è¯‘é™æ€è¯­è¨€çš„ç¼–è¯‘ç‰¹æ€§
é¦–å…ˆæŒ‰ç…§é¢˜ç›®çš„è¦æ±‚åˆ›å»ºé¡¹ç›®å¹¶è¿›è¡Œç¼–è¯‘ä¼šæŠ¥é”™æ— æ³•æ‰¾åˆ°bonjourè¿™ä¸ªæ–‡ä»¶ error: use of undeclared identifier 'function'
å› ä¸ºä»ä¸»main.cppå…¥å£è¿›å…¥åç›´æ¥è¿è¡Œäº†bonjourä½†æ˜¯å¹¶æ²¡æœ‰å¼•å…¥è¿™ä¸ªæ–‡ä»¶çš„å£°æ˜

æ”¹æ­£æ–¹æ¡ˆæœ‰ä¸¤ç§:ï¼ˆå¯ä»¥çœ‹Ex03æ–‡ä»¶å¤¹ï¼‰
- 1.ç›´æ¥åœ¨main.cppä¸Šé¢å£°æ˜ void function(); å³å¯
- 2.é€šè¿‡è‡ªå®šä¹‰å¤´æ–‡ä»¶ decFunction.h ä¸­ç»Ÿä¸€è¿›è¡Œå£°æ˜ç®¡ç†ï¼Œç„¶ååœ¨ main.cpp ä¸­è¿›è¡Œå¯¼å…¥å³å¯
    ï¼ˆæœ‰ç‚¹åƒä¸€ä¸ªæ–‡ä»¶å¤¹ä¸­é€šè¿‡å¤šä¸ªå°æ–‡ä»¶å»å®ç°ä¸€ä¸ªä¸ªåŠŸèƒ½å‡½æ•°ï¼Œç„¶åè®¾ç½®ä¸€ä¸ª index å»ç»Ÿä¸€è¿›è¡Œå¯¼å‡ºç®¡ç†ï¼‰

ä¸‹é¢é€šè¿‡C++çš„ç¼–è¯‘è¿‡ç¨‹ç†è§£æ˜¯ä¸ºä»€ä¹ˆï¼š
1. é¢„å¤„ç†é˜¶æ®µï¼šä»ä¸»å¤´mainè¿›å…¥åä¼šæŸ¥çœ‹æœ‰å“ªäº›å£°æ˜ï¼Œç„¶åé€šè¿‡è¿™äº›å£°æ˜ç¨ååœ¨é“¾æ¥é˜¶æ®µå»å…¶ä»–æ–‡ä»¶ä¸­å¯»æ‰¾
    #include å°±æ˜¯ç›¸å½“äºå°†æ•´ä¸ªæ–‡ä»¶æ‹·è´è¿‡æ¥ï¼Œæ‰€ä»¥æ¨èçš„æ–¹æ³•æ˜¯å†™ä¸€ä¸ªç»Ÿä¸€å£°æ˜ç®¡ç†çš„å¤´æ–‡ä»¶åå¯¼å…¥
2. ç¼–è¯‘é˜¶æ®µï¼šå°†æ¯ä¸ª .cpp æ–‡ä»¶è¿›è¡Œç‹¬ç«‹ç¼–è¯‘
3. é“¾æ¥é˜¶æ®µï¼šæ ¹æ®é¢„å¤„ç†é˜¶æ®µçš„â€æˆ‘éœ€è¦...å‡½æ•°â€œçš„å¼•ç”¨ï¼Œå½“å‰é¡¹ç›®ä¸­ -> é™æ€åº“ -> åŠ¨æ€åº“ ä¸­å»å¯»æ‰¾ï¼ˆæ‰€ä»¥æ˜¯æœ‰ä¼˜å…ˆçº§çš„ï¼‰
*/
```


# Ex03 æ–‡ä»¶å¤¹
## decFunction.h
```h
#ifndef DECFUNCTION_H // å‘½åè§„èŒƒï¼šå¤§å†™åŒ–å¤´æ–‡ä»¶åç§°
#define DECFUNCTION_H
// å¤´æ–‡ä»¶ä¿æŠ¤ï¼Œç”¨äºå¤´æ–‡ä»¶å…¶ä»–æ–‡ä»¶è¢«å¤šæ¬¡å¯¼å…¥æ—¶ä¸ä¼šé‡å¤å£°æ˜

void function();

#endif
```

## function.cpp
```cpp
#include<iostream>
using namespace std;

void function(){
    cout<<"æˆåŠŸè°ƒç”¨å‡½æ•°"<<endl;
}
```

## main.cpp
```cpp
// void function();
#include "decFunction.h"

int main(){
    function();
    return 0;
}
```


# Ex04
```cpp
/*
é¢˜ç›®çš„æ„æ€æ˜¯åœ¨ A.h ä¸­å¼•ç”¨ B.h ï¼Œç„¶ååˆåœ¨ B.h ä¸­å¼•ç”¨ A.h
è¿™ä¼šå¯¼è‡´å¾ªç¯å¼•ç”¨çš„é—®é¢˜
å› ä¸ºåœ¨C++çš„é¢„å¤„ç†é˜¶æ®µä¸­#includeæ˜¯ çº¯æ–‡æœ¬æ›¿æ¢ ï¼Œæ‰€ä»¥ä¼šæ— é™å±•å¼€
ï¼ˆåƒJSã€pyè¿™äº›åŠ¨æ€è¯­è¨€åœ¨æ‰§è¡Œå¾ªç¯å¯¼å…¥çš„æŠ¥é”™æ˜¯å¯¼å…¥æœªå®Œå…¨ã€å¯¼å…¥æ—¶æ¨¡å—ä½“è¿˜æœªæ‰§è¡Œå®Œå…¨ï¼‰
*/
```


# Ex05
```cpp
/*
reecrire re-ecrire é‡æ–°å†™
ne faisant appel. quâ€™aux nouvelles possibilites dâ€™entrees-sorties du C++ : åªä½¿ç”¨ C++ çš„æ–°è¾“å…¥è¾“å‡ºåŠŸèƒ½
ä½¿ç”¨ const å®šä¹‰å¸¸é‡è€Œä¸æ˜¯ #define
*/

#include <iostream>

constexpr double PI = 3.14159;
// constexpræŒ‡ç¼–è¯‘æœŸå·²çŸ¥ï¼Œå¯ä»¥ç›´æ¥åœ¨ç¼–è¯‘æœŸä½¿ç”¨ï¼Œè€Œä¸ç”¨åƒconstå¾—åœ¨è¿è¡Œæ—¶å»å†…å­˜é‡Œé¢æ‹¿ï¼Œæ¯”constæ€§èƒ½æ›´ä¼˜

void calculateCircle()
{
    std::cout << "è¯·è¾“å…¥åœ†çš„åŠå¾„: ";
    double r;

    if (!(std::cin >> r) || r < 0)
    {
        std::cout << "è¾“å…¥é”™è¯¯ï¼åŠå¾„å¿…é¡»ä¸ºéè´Ÿæ•°ã€‚" << std::endl;
        return;
    }

    double circumference = 2 * PI * r;
    // double area = PI * r * r;
    double area = PI * std::pow(r, 2);

    std::cout << "åœ†çš„å‘¨é•¿: " << circumference << '\n';
    std::cout << "åœ†çš„é¢ç§¯: " << area << '\n';
}

int main()
{
    calculateCircle();
    return 0;
}
```


# Ex06
```cpp
#include <iostream>

int main()
{
    double x = 3.14;
    std::cout << x << std::endl;
    double y;
    std::cout << y << std::endl;
    y = 3.14;
    std::cout << y << std::endl;
    return 0;
}

/*
è¿™é“é¢˜æ˜¯ç”¨äºåŒºåˆ† å£°æ˜ã€å®šä¹‰ã€åˆå§‹åŒ–ã€èµ‹å€¼
å£°æ˜ç”¨äºå‘Šè¯‰ç¼–è¯‘å™¨è¿™ä¸ªè¯¥å˜é‡å­˜åœ¨ä¸”å…¶ç±»å‹æ˜¯ä»€ä¹ˆï¼Œæ–¹ä¾¿åœ¨å†…å­˜ä¸­å¼€ä¸€ç‰‡åŒºåŸŸ
åƒå±€éƒ¨å˜é‡çš„å®šä¹‰å°±ä¸ä¼šç»™åˆå§‹å€¼ï¼Œä½†æ˜¯å¦‚æœæ˜¯å…¨å±€çš„è¯ç¼–è¾‘å™¨ä¼šé»˜è®¤åˆå§‹åŒ–ä¸º0
åˆå§‹åŒ–å°±æ˜¯åœ¨å£°æ˜çš„æ—¶å€™é€šè¿‡ = èµ‹å€¼ç¬¦å·ç»™å…¶ä¸€ä¸ªåˆå€¼
ä½†æ˜¯ä¹Ÿä¸ä¸€å®šéœ€è¦åœ¨å£°æ˜çš„æ—¶å€™èµ‹åˆå€¼ï¼Œä¹Ÿå¯ä»¥å…ˆå£°æ˜åœ¨åé¢å†è°ƒç”¨è¿™ä¸ªå˜é‡è¿›è¡Œèµ‹å€¼
æ³¨æ„å¦‚æœåœ¨ä¸€ä¸ªå˜é‡æ²¡æœ‰å€¼ä¹‹å‰å»coutè¾“å‡ºï¼Œå°±ä¼šè¾“å‡ºéšæœºæ•°ï¼Œä¾‹å¦‚è¿™å—å†…å­˜å¯èƒ½æ®‹ç•™ç€ä¹‹å‰ç¨‹åºæˆ–æ“ä½œç³»ç»Ÿçš„æ•°æ®
*/
```


# Ex07
```cpp
/*
è¿™é“é¢˜ç›®æ˜¯æ•™å­¦å¸¸é‡ä¸å¯å˜ï¼š
ä¸€æ—¦ä½ å£°æ˜å‰æœ‰ const çš„æ—¶å€™å¦‚æœåé¢æƒ³å°è¯•å¯¹è¯¥å˜é‡èµ‹å€¼å°±ä¼šæŠ¥é”™ï¼Œä¸€èˆ¬ç”¨äºç¼–è¯‘å™¨çš„æ€§èƒ½ä¼˜åŒ–
ï¼ˆæ’ä¸€å˜´ï¼šä¸€èˆ¬å¸¸é‡å‘½åç”¨å¤§å†™è§„åˆ™ï¼Œè¿™æ ·å…¶ä»–ä»“åº“ç®¡ç†è€…å°±çŸ¥é“è¿™æ˜¯ä¸ªå¸¸é‡äº†ï¼‰
 */

int main()
{
    const double PI = 3.14;
    // PI = 314;
    return 0;
}
```


# Ex08
```cpp
/*
è¿™é“é¢˜ä¸»è¦å±•ç¤ºäº†å‘½åç©ºé—´çš„ç”¨é€”ï¼šéšç€ä»“åº“çš„è¶Šæ¥è¶Šå¤§ã€æ¨¡å—è¶Šæ¥è¶Šå¤šï¼Œ
å‘½åç›¸åŒçš„æƒ…å†µå¯èƒ½ä¼šå‘ç”Ÿï¼Œä¾‹å¦‚ py çš„ä¸åŒåº“ä¸­å¯èƒ½æœ‰ç›¸åŒåç§°çš„æ–¹æ³•ï¼Œpyæ˜¯é€šè¿‡ åº“å. è¿›è¡ŒåŒºåˆ†ï¼Œ
è¿˜æœ‰å¸¸è§çš„é€šè¿‡è¯¦ç»†å‘½åã€å¤§é©¼å³°å°é©¼å³°ç­‰æ–¹å¼å»åŒºåˆ†ï¼Œ
ä½†æ˜¯C++ä¸­æœ‰namespaceå°±å…è®¸äº†åŒåï¼Œå’Œpyçš„ ç±». ç›¸ä¼¼çš„é€šè¿‡ :: è¿›è¡Œå¼•ç”¨ä»è€ŒåŒºåˆ†
è¯¦æƒ…è¯·çœ‹Ex08æ–‡ä»¶å¤¹:
- decFunction.h å¤´æ–‡ä»¶å£°æ˜
- function.cpp å‡½æ•°å®ç°æ–‡ä»¶
- main.cpp ä¸»é€»è¾‘ã€è°ƒç”¨æ–‡ä»¶
*/```


# Ex08 æ–‡ä»¶å¤¹
## decFunction.h
```h
#ifndef DECFUNCTION_H
#define DECFUNCTION_H

#include <iostream> // ç”¨äºå„ä¸ªå­æˆå‘˜ï¼Œåœ¨è¿™é‡Œç»Ÿä¸€å¯¼å…¥å°±ä¸ç”¨ä¸€ä¸ªä¸ªå»å†™äº†

namespace French
{
    void sayhi();
}

namespace China
{
    void sayhi();
}

namespace English
{
    void sayhi();
}

#endif```

## function.cpp
```cpp
#include "decFunction.h"
// å¯¼å…¥å¤´æ–‡ä»¶ä¸­çš„å‘½åç©ºé—´ç”¨äºåŒºåˆ†ï¼Œå¹¶ä¸”iostreamä¹Ÿæ˜¯åœ¨å¤´æ–‡ä»¶ç»Ÿä¸€å¯¼å…¥äº†

void French::sayhi()
{
    std::cout << "bonjour" << std::endl;
}

void English::sayhi()
{
    std::cout << "hi" << std::endl;
}

void China::sayhi()
{
    std::cout << "ä½ å¥½" << std::endl;
}```

## main.cpp
```cpp
#include "decFunction.h"
// åªéœ€è¦å¯¼å…¥åŒ…å«å£°æ˜çš„å¤´æ–‡ä»¶å³å¯ï¼Œè‡³äºå®ç°éƒ¨åˆ†åˆ°æ—¶å€™ç¼–è¯‘å™¨è‡ªå·±ä¼šå»æ‰¾ï¼ˆä½†æ˜¯åˆ«å¿˜è®°ç¼–è¯‘å®ç°çš„functionæ–‡ä»¶ï¼‰

int main()
{
    French::sayhi();
    English::sayhi();
    China::sayhi();
    return 0;
}
```


# Ex09
```cpp
/*
è¿™é“é¢˜ä¸»è¦è€ƒå¯Ÿäº†é‡è½½ã€å†…è”å‡½æ•°

- åœ¨ç¼–è¯‘æœŸå¤„ç†å“ªä¸ªå‡½æ•°ç­¾åæœ€åŒ¹é…
- é‡è½½ï¼šåŒåä½†æ˜¯ä¸åŒå‚æ•°åˆ—è¡¨ï¼ˆè¿”å›ç±»å‹ä¸å‚ä¸ã€å½¢å‚é¡¶å±‚çš„constä¸å‚ä¸ï¼‰
    - ç¼–è¯‘å™¨å†…éƒ¨å¯¹é‡è½½çš„è§£æï¼š
        - 1. å€™é€‰é›†ï¼šæ‰¾åˆ°æ‰€æœ‰åŒåå‡½æ•°;
        - 2. å¯è¡Œé›†ï¼šèƒ½é€šè¿‡éšå¼è½¬æ¢æŠŠå®å‚è½¬æ¢ä¸ºå½¢å‚çš„å‡½æ•°
        - 3. æœ€ä½³å¯è¡Œå‡½æ•°ï¼šæ¯”è¾ƒæ¯ä¸ªå‚æ•°çš„è½¬æ¢â€œä¼˜åŠ£â€ï¼Œé€‰æ•´ä½“æ›´ä¼˜çš„é‚£ä¸ªï¼›è‹¥æ— å”¯ä¸€æ›´ä¼˜ => äºŒä¹‰æ€§æŠ¥é”™
    - ä¼˜åŠ£æ’åºï¼š
        - 1. ç²¾å‡†åŒ¹é…ï¼šç±»å‹å®Œå…¨ç›¸åŒã€æˆ–ä»…é™åº•å±‚cvçš„è°ƒæ•´
        - 2. æå‡ï¼š
            - a. æå‡æ•´å‹ï¼šbool/char/signed char/unsigned char/short => intï¼ˆæˆ– unsigned intï¼‰
            - b. æå‡æµ®ç‚¹ï¼šfloat => double
        - 3. è½¬æ¢ï¼šint <=> floatã€double => floatã€double => intã€unsigned <=> signedã€æ´¾ç”Ÿ => åŸºç±»ç­‰
    - æ¶ˆæ­§ä¿®æ­£ï¼š
        - 1. æ˜¾å¼ç±»å‹è½¬æ¢ï¼šè°ƒç”¨ (float)i ç­‰
        - 2. æ·»åŠ åç¼€å­—é¢é‡ï¼šå¦‚ 3.0f ï¼ˆæœ‰ç‚¹åƒTSé‡Œçš„ i as float )

- å¦‚æœåœ¨éœ€è¦å°†å‡½æ•°ä½“å†™åœ¨å¤´æ–‡ä»¶ä¸­ï¼Œè€Œä¸”è¿™ä¸ªå¤´æ–‡ä»¶è¢«å¤šæ¬¡å¯¼å…¥ï¼Œé‚£ä¹ˆç”±äº include ä¼šç›¸å½“äºåµŒå…¥ä»£ç ä¼šå¯¼è‡´åœ¨é“¾æ¥æœŸå¤´æ–‡ä»¶ä¸­å‡½æ•°ä½“è¢«å¤šæ¬¡å®šä¹‰
- ä¸ºäº†å¤„ç† ODRï¼ˆOne Definition Ruleï¼‰ï¼š
    - !Important: æœ€æ¨èçš„åšæ³•å°±æ˜¯åœ¨åŠŸèƒ½å¤´æ–‡ä»¶ä¸­å†™å‡½æ•°å£°æ˜ï¼Œå°†åŠŸèƒ½å‡½æ•°çš„å‡½æ•°ä½“åœ¨å•ç‹¬çš„ cpp ä¸­å®ç°ï¼Œé‚£ä¹ˆå…¶ä»–åœ°æ–¹è¦ä½¿ç”¨çš„æ—¶å€™åªéœ€è¦å¯¼å…¥è¿™ä¸ªåŠŸèƒ½å‡½æ•°çš„å£°æ˜å¤´æ–‡ä»¶ã€ç›¸å½“äºä½¿ç”¨çš„æ˜¯åŒä¸€ä¸ª
    - 1. å¤´æ–‡ä»¶staticï¼šï¼ˆæœ‰ç‚¹åƒé—­åŒ…ã€ç±»é‡Œé¢çš„é™æ€ç§æœ‰å‡½æ•°ï¼‰åªèƒ½åœ¨å®šä¹‰å…¶æ–‡ä»¶å†…éƒ¨ä½¿ç”¨ï¼Œæ§åˆ¶äº†ä½œç”¨åŸŸï¼Œå„ TU å„æœ‰ä¸€ä»½å‡½æ•°ä½“ï¼›å¯é¿å…é‡å®šä¹‰ï¼Œä½†å¯èƒ½å¯¼è‡´é‡å¤ä»£ç 
    // - 2. å® #defineï¼šæ— ç±»å‹/ä½œç”¨åŸŸæ£€æŸ¥ï¼Œä¸è¦ç”¨æ¥æ›¿ä»£å‡½æ•°ï¼›inline æ˜¯æ›´å®‰å…¨çš„å®æ›¿ä»£å“
    // - 3. constexprï¼šéšå« inlineï¼›è¦æ±‚å‡½æ•°åœ¨ç¼–è¯‘æœŸå¯æ±‚å€¼ï¼ˆæ»¡è¶³é™åˆ¶ï¼‰
    - 4. inline å†…è”ï¼šç¼–è¯‘å™¨ä¼šå°†å†…è”å‡½æ•°çš„ä»£ç ç›´æ¥æ’å…¥åˆ°è°ƒç”¨ç‚¹ï¼Œé¿å…å‡½æ•°è°ƒç”¨çš„å‹æ ˆã€è·³è½¬ã€è¿”å›ç­‰æ“ä½œï¼ˆæ¯”å¦‚ DFS ä¸å½“å¸¸å¸¸ä¼šå¯¼è‡´çˆ†æ ˆï¼Œä½†æ˜¯é€’å½’ä¹Ÿæ²¡æ³•ç”¨inlineä¼šå¯¼è‡´ä»£ç è†¨èƒ€çš„é—®é¢˜ï¼Œå¯ä»¥é€šè¿‡è‡ªå·±ç»´æŠ¤æ ˆæ˜¾å¼ä½¿ç”¨æ¥ä¼˜åŒ–ï¼‰

è¯¦ç»†å†…å®¹çœ‹ Ex9 æ–‡ä»¶å¤¹
*/```


# Ex09 æ–‡ä»¶å¤¹
## decFunction.h
```h
// #ifndef DECFUNCTION_H
// #define DECFUNCTION_H

// #include <string>
// // #include <iostream>

// void func(int a);
// void func(int a2, std::string b2);
// void func(int a3, std::string b3, float c3);
// // int func(int a);
// // float func(int a);
// // æŠ¥é”™: æ— æ³•é‡è½½ä»…æŒ‰è¿”å›ç±»å‹åŒºåˆ†çš„å‡½æ•°ï¼Œå› ä¸ºè¿”å›ç±»å‹ä¸å‚ä¸é‡è½½
// int func(double a);

// #endif

#ifndef DECFUNCTION_H
#define DECFUNCTION_H

#include <string>
#include <iostream>

inline void func(int a) // æ³¨æ„inlineå¿…é¡»è¦å°†å‡½æ•°ä½“ä¹Ÿä¸€èµ·å†™å‡ºæ¥ä¸èƒ½åªæ˜¯å£°æ˜ï¼ˆå› ä¸ºåˆ°æ—¶å€™æ˜¯ç›´æ¥ç²˜è´´è¿‡å»çš„ï¼‰
{
    std::cout << "æˆåŠŸè°ƒç”¨å‡½æ•°1" << a << std::endl;
}

inline void func(int a2, std::string b2)
{
    std::cout << "æˆåŠŸè°ƒç”¨å‡½æ•°2" << a2 << ' ' << b2 << std::endl;
}

inline void func(int a3, std::string b3, float c3)
{
    std::cout << "æˆåŠŸè°ƒç”¨å‡½æ•°3" << a3 << ' ' << b3 << ' ' << c3 << std::endl;
}
// int func(int a);
// float func(int a);
// æŠ¥é”™: æ— æ³•é‡è½½ä»…æŒ‰è¿”å›ç±»å‹åŒºåˆ†çš„å‡½æ•°ï¼Œå› ä¸ºè¿”å›ç±»å‹ä¸å‚ä¸é‡è½½

inline int func(double a)
{
    std::cout << "æˆåŠŸè°ƒç”¨å½¢å‚ä¸ºdoubleç±»å‹çš„å‚æ•°" << a << std::endl;
}

#endif```

## usePlace2.h
```h
#ifndef USEPLACE2_H
#define USEPLACE2_H

int test();

#endif```

## functions.cpp
```cpp
/*

è¿™æ˜¯æˆ‘é¦–æ¨çš„åŠŸèƒ½å‡½æ•°å•ç‹¬æ–‡ä»¶å†™æ³•ï¼Œä¸ºäº†å±•ç¤º inline å°±å…ˆæ³¨é‡Šæ‰äº†

#include <iostream>

void func(int A)
{
    std::cout << "æˆåŠŸè°ƒç”¨å‡½æ•°1" << A << std::endl;
}

void func(int A2, std::string B2)
{
    std::cout << "æˆåŠŸè°ƒç”¨å‡½æ•°2" << A2 << ' ' << B2 << std::endl;
}

void func(int A3, std::string B3, float C3)
{
    std::cout << "æˆåŠŸè°ƒç”¨å‡½æ•°3" << A3 << ' ' << B3 << ' ' << C3 << std::endl;
}

int func(double A)
{
    std::cout << "æˆåŠŸè°ƒç”¨å½¢å‚ä¸ºdoubleç±»å‹çš„å‚æ•°" << A << std::endl;
}
*/```

## main.cpp
```cpp
#include "decFunction.h"
#include "usePlace2.h"

int main()
{
    func(1);
    func(1, "2");
    func(1, "2", 3.0);
    func(1.0000000000000000000000); // ç²¾å‡†åŒ¹é…ä¼˜å…ˆçº§å¤§äºæå‡æ•´å‹çš„ä¼˜å…ˆçº§

    std::cout << '\n'
              << "å°è¯•è°ƒç”¨ç¬¬äºŒä¸ªä½¿ç”¨ç›¸åŒå¤´æ–‡ä»¶å‡½æ•°ä½“çš„å‡½æ•°" << std::endl
              << '\n';

    test();

    return 0;
}```

## usePlace2.cpp
```cpp
#include "decFunction.h"
#include "usePlace2.h"

int test()
{
    func(12);
    func(12, "22");
    func(12, "22", 23.0);
    func(12.0000000000000000000000); // ç²¾å‡†åŒ¹é…ä¼˜å…ˆçº§å¤§äºæå‡æ•´å‹çš„ä¼˜å…ˆçº§
    return 0;
}

/*
å¦‚æœæ²¡æœ‰åœ¨ decå¤´æ–‡ä»¶ ä¸­ä½¿ç”¨inlineä¼šå‘ç°æŠ¥é”™:
1 warning generated.
duplicate symbol '_${å‡½æ•°å}' in:
    å¤šä¸ªæ–‡ä»¶è·¯å¾„
ld: 1 duplicate symbol for architecture arm64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
*/
```


# Ex10
```cpp
#include <iostream>

int main()
{
    /*
        * : 1. å£°æ˜æŒ‡é’ˆ;2. è§£å¼•ç”¨å–å€¼
        1. int* ptr; // è¡¨ç¤ºå£°æ˜äº†ä¸€ä¸ªæŒ‡å‘æ•´å‹ç±»å‹çš„æŒ‡é’ˆ
        2. int value = *ptr; // è§£æŒ‡é’ˆæ‹¿åˆ°äº† ptr æŒ‡é’ˆæŒ‡å‘çš„å€¼å¹¶èµ‹å€¼ç»™å¦ä¸€ä¸ªå˜é‡
    */
    /*
        & : 1. å£°æ˜å¼•ç”¨;2. å–åœ°å€
        1. int& ref = var; // å£°æ˜äº† ref æŒ‡å‘çš„å’Œ var åŒä¸€ä¸ªå†…å­˜åœ°å€
        2. int* ptr = &ref; // ptr æŒ‡å‘çš„æ˜¯å˜é‡ ref çš„å†…å­˜åœ°å€
    */

    double *pt0 = 0;              // 0 å¯ä»¥æ˜¯ int,double,float,long,char,ç©ºæŒ‡é’ˆï¼šè¿™é‡Œç”¨åˆ°çš„å°±æ˜¯ double ç±»å‹
    double *pt1;                  // = 4096; // å˜é‡å’ŒæŒ‡é’ˆçš„ç±»å‹å¿…é¡»ç›¸åŒï¼š4096æ˜¯ int ç±»å‹
    double *pt2 = (double *)4096; // å°†æŒ‡é’ˆè¿›è¡Œäº†æ˜¾å¼è½¬æ¢ã€‚ä½†è¿™æ˜¯å±é™©çš„ï¼Œå¦‚æœè§£å¼•ç”¨å°±ä¼šå¯¼è‡´undefinedè¡Œä¸º
    void *pt3 = pt1;              // ä»»æ„å¯¹è±¡ç±»å‹çš„æŒ‡é’ˆï¼Œéƒ½å¯ä»¥éšå¼è½¬æ¢ç»™ void*
    // pt1 = pt3;                 // ä½†æ˜¯ void* ç±»å‹èµ‹ç»™å…¶ä»–çš„å¿…é¡»è¿›è¡Œæ˜¾å¼è½¬æ¢ï¼šå¦‚ä¸‹é¢ä¸€è¡Œ
    pt1 = (double *)pt3;

    // const ç±»å‹ *ptr ï¼šæŒ‡é’ˆæŒ‡å‘çš„å€¼ä¸èƒ½å˜
    // ç±»å‹ const *ptr ï¼šå’Œä¸Šé¢ä¸€æ ·éƒ½æ˜¯å€¼ä¸èƒ½å˜

    // ç±»å‹ * const ptr ï¼šconstç´§æ¥ptr - æŒ‡é’ˆä¸ºå¸¸é‡ä¸èƒ½å˜

    double d1 = 36;
    const double d2 = 36;
    double *pt4 = &d1;
    const double *pt5 = &d1;
    std::cout << "--d1: " << d1 << std::endl;
    *pt4 = 2.1; // é€šè¿‡ d1 çš„æŒ‡é’ˆ pt4 æ¥ä¿®æ”¹ d1 çš„å€¼
    std::cout << "--d1: " << d1 << std::endl;
    // *pt5 = 2.1; // ä¸Šé¢åŠ äº† const å¯¼è‡´è¿™ä¸ªæŒ‡é’ˆæ— æ³•æ”¹å˜
    // pt4 = &d2; // ä¸èƒ½å°†å€¼èµ‹ç»™æŒ‡é’ˆå˜é‡
    pt5 = &d2;
    double *const pt6 = &d1;
    // pt6 = &d1; // ä¸Šé¢å®šä¹‰äº†ä¸å¯å˜æŒ‡é’ˆ
    *pt6 = 2.78;
    // double *const pt6b = &d2; // æ³¨æ„ pt6b æ˜¯æŒ‡é’ˆä¸å¯å˜ï¼Œä½†æ˜¯ d2 æ˜¯å€¼ä¸å¯å˜
    const double *const pt6b = &d2; // è‡ªèº«æ›´ä¸¥æ ¼çš„å¯ä»¥æŒ‡å‘ï¼ˆåŒconstå¯æŒ‡1constï¼Œ1constå¯ä»¥æŒ‡0constï¼Œä½†æ˜¯1å¯¹1çš„æ—¶å€™å°±éœ€è¦åˆ¤æ–­æ˜¯å¦æ˜¯åŒä¸€ä¸ªconstï¼‰
    const double *const pt7 = &d1;
    // pt7 = &d1; // pt7çš„å€¼å’ŒæŒ‡é’ˆéƒ½ä¸å¯å˜
    // *pt7 = 2.78;
    double const *pt8 = &d1; // æ³¨æ„ä¸æ˜¯ç±»å‹ç´§æ¥ï¼Œæ‰€ä»¥æ˜¯å€¼ä¸èƒ½å˜
    pt8 = &d2;               // éƒ½æ˜¯å€¼const
    pt8 = &d1;
    // *pt8 = 3.14;          // å€¼ä¸èƒ½å˜

    return 0;
}
```


# Ex11
```cpp
#include <iostream>

int main()
{
    /*
    constå¼•ç”¨ï¼šå¼•ç”¨æŒ‡å‘çš„å€¼æ˜¯å¸¸é‡
    const ç±»å‹& ref
    ç±»å‹ const& ref
    */

    // double &d1 = 36; // é const çš„å¼•ç”¨ä¸èƒ½è¢«èµ‹ä¸´æ—¶é‡ï¼ˆè¿™é‡Œçš„36ä¼šè¢«ä¸´æ—¶éšå¼è½¬æ¢doubleï¼Œä½†æ˜¯ç”Ÿå‘½å‘¨æœŸé©¬ä¸Šåˆ°å¤´æ‰€ä»¥ä¸èƒ½è¢«å¼•ç”¨ï¼‰
    double d2 = 36;
    double &ref = d2;
    std::cout << "--d2: " << ref << std::endl;
    ref = 4; // ä¸æ˜¯ const å¯ä»¥ç›´æ¥æ›´æ”¹
    std::cout << "--d2: " << ref << std::endl;

    const double d3 = 36;
    const double &d4 = 36; // è¿™é‡Œçš„ 36 çš„ç”Ÿå‘½å‘¨æœŸä¼šè¢«å»¶é•¿åˆ° d4 çš„ä½œç”¨åŸŸç»“æŸ
    const double &d5 = d2;
    // d5 = 21; // æ— æ³•æ›´æ”¹ const
    const double &d6 = d3;
    // double &ref2 = d6; // è‡ªèº«å¾—æ›´ä¸¥æ ¼ï¼Œd6ä¸ºconsté‚£ä¹ˆå·¦è¾¹ä¹Ÿå¿…é¡»å¾—const
    int i = 4;
    // double &d7 = i; // åœ¨éœ€è¦éšå¼ç±»å‹è½¬æ¢çš„æ—¶å€™èµ‹å€¼ç»™å¼•ç”¨çš„æ˜¯ä¸­é—´çš„ä¸´æ—¶å˜é‡ï¼Œæ¯”å¦‚è¿™é‡Œå°±æ˜¯static_cast<double>(i)ï¼Œé‚£ä¹ˆå°±å’Œä¸Šé¢çš„é const å¼•ç”¨ä¸èƒ½è¢«èµ‹å€¼ä¸´æ—¶å˜é‡ä¸€æ ·äº†
    const double &d7 = i; // const ç±»å‹çš„å¯ä»¥èµ‹å€¼ä¸´æ—¶å˜é‡/å­—é¢é‡ï¼Œä¼šäº§ç”Ÿä¸´æ—¶å¯¹è±¡å¹¶å»¶é•¿å…¶ç”Ÿå‘½å‘¨æœŸ
    const double &d8 = i;
    // d8 = 3; // constäº†

    return 0;
}
```


# Ex12 æ–‡ä»¶å¤¹
## dec.h
```h
#ifndef DEC_H
#define DEC_H

void inverseByPtr(int *a, int *b);
void inverseByRef(int &a, int &b);

#endif
```

## functions.cpp
```cpp
#include <iostream>

// åˆ©ç”¨åœ°å€æˆ–è€…å¼•ç”¨ã€é€šè¿‡ä¸­é—´å˜é‡æˆ–è€…è§£æ„ç­‰æ–¹æ³•è¿›è¡Œäº¤æ¢
// å¦‚æœä¸ç”¨åœ°å€æˆ–å¼•ç”¨è€Œæ˜¯ç›´æ¥ä¼ (int a,int b)ä¼šå¯¼è‡´ä¼ å…¥çš„åªæ˜¯aå’Œbçš„å€¼æ‹·è´ï¼Œæ— æ³•æ”¹å˜å†…å­˜å±‚é¢çš„å€¼
// è€Œåƒpythonã€JSã€Javaè¿™äº›è¯­è¨€ä¸éœ€è¦æŒ‡é’ˆä¹Ÿèƒ½æˆåŠŸæ”¹å˜çš„åŸå› æ˜¯è¿™äº›è¯­è¨€å°äº†ä¸€å±‚ä½¿å¾—ä¼ å…¥çš„å…¶å®æ˜¯ä¸€ä¸ªå¼•ç”¨å¯¹è±¡ï¼Œé‚£ä¹ˆä½¿ç”¨è€…å°±ä¸éœ€è¦è€ƒè™‘å†…å­˜çš„ç»†èŠ‚äº†
// ä½†æ­£æ˜¯å› ä¸º C++ çš„é¢—ç²’åº¦å°æ‰€ä»¥åœ¨æ€§èƒ½ä¸Šéå¸¸æœ‰ä¼˜åŠ¿ï¼Œä¸”ä¼šé¿å…è¯­è¨€å¼€å‘è€…å‡ºäºå¥½æ„çš„å°è£…å¯¼è‡´çš„ä½¿ç”¨è€…åœ¨è°ƒç”¨APIæ—¶è¢«æ— æ„ç¯¡æ”¹äº†æ•°æ®

void inverseByPtr(int *a, int *b)
{
    std::cout << "æŒ‡é’ˆä¼ é€’å‰a,bå€¼: " << *a << ',' << *b << std::endl;
    int temp = *a;
    *a = *b;
    *b = temp;
    std::cout << "æŒ‡é’ˆä¼ é€’åa,bå€¼: " << *a << ',' << *b << std::endl;
}
void inverseByRef(int &a, int &b)
{
    std::cout << "å¼•ç”¨ä¼ é€’å‰a,bå€¼: " << a << ',' << b << std::endl;
    // int temp = a;
    // a = b;
    // b = temp;
    std::tie(a, b) = std::make_tuple(b, a); // é€šè¿‡å…ƒç»„è§£æ„çš„æ–¹å¼
    std::cout << "å¼•ç”¨ä¼ é€’åa,bå€¼: " << a << ',' << b << std::endl;
}
```

## main.cpp
```cpp
#include "dec.h"

int main()
{
    int A = 100;
    int B = -100;

    int *strA = &A;
    int *strB = &B;

    int &refA = A;
    int &refB = B;

    inverseByPtr(strA, strB);
    inverseByRef(refA, refB);

    return 0;
}
```


# Ex12
```cpp
// é¢˜ç›®è¦æ±‚ç”¨ æŒ‡é’ˆä¼ é€’ å’Œ å¼•ç”¨ä¼ é€’ ä¸¤ç§æ–¹å¼äº¤æ¢ä¸¤ä¸ªå˜é‡çš„å€¼
// è¯¦æƒ…è§ Ex12 æ–‡ä»¶å¤¹
```


# Ex13
```cpp
#include <iostream>
/*
é¢˜é¢ï¼šç¼–å†™ä¸€ä¸ªåä¸ºrazçš„å‡½æ•°ï¼Œç”¨äºå°†ä¼ å…¥å‚æ•°ä¸­çš„æ­¤ç±»ç»“æ„ä½“ä¸­ä¸¤ä¸ªå­—æ®µé‡ç½®ä¸ºé›¶ã€‚
ä½¿ç”¨åœ°å€å‚æ•°æ‰§è¡Œä¸€æ¬¡ï¼Œä½¿ç”¨å¼•ç”¨å‚æ•°æ‰§è¡Œä¸€æ¬¡ã€‚åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œéƒ½éœ€è¦ç¼–å†™ä¸€ä¸ªç®€å•çš„å‡½æ•°æµ‹è¯•ç¨‹åºã€‚è¯¥ç¨‹åºåœ¨è°ƒç”¨æ­¤å‡½æ•°åä¼šæ˜¾ç¤ºæ­¤ç±»ç»“æ„ä½“çš„å€¼
*/

struct essai
{
    int n;
    float x;
};

// åˆ©ç”¨é‡è½½æ€§è´¨ï¼ˆè™½ç„¶åœ¨å…¶ä»–è¯­è¨€ä¸­æœ€å¥½æ˜¯é€šè¿‡è¯¦ç»†åå­—åŒºåˆ†å‡½æ•°ï¼Œä½†æ˜¯C++å¯ä»¥åˆ©ç”¨é‡è½½è‡ªåŠ¨åˆ†æµä¼˜åŒ–æ€§èƒ½ï¼‰
/**
 * æ­¤å¤„æ˜¯å‡½æ•°è¯´æ˜ï¼Œç”¨äºä»“åº“ä»£ç çš„ç»´æŠ¤ï¼Œæœ¬è¯¾ç¨‹ä¸éœ€è¦ï¼Œä½†æ˜¯å·¥ç¨‹åŒ–æœ€å¥½å¤šæ³¨æ˜æ–¹ä¾¿ä»–äººè¿›ä¸€æ­¥è´¡çŒ®
 * @brief Reset fields of essai to zero (pass by address)
 * @param e Pointer to essai struct
 */
void raz(struct essai *e) noexcept // noexcept æ˜¯ä¸ºäº†é˜²æ­¢å¤„ç† const çš„æ—¶å€™ç¼–è¯‘æŠ›é”™è¯¯
{
    // æ‹¿åˆ°ç»“æ„ä½“æŒ‡é’ˆéœ€è¦å…ˆè§£å¼•ç”¨å†æ‹¿å…ƒç´ å€¼ (*p).n ï¼Œé‚£ä¹ˆæœ‰ä¸€ä¸ªç­‰ä»·è¯­æ³•ç³–å°±æ˜¯ p->n ï¼ˆå¦‚æœæ˜¯å¼•ç”¨çš„è¯å°±åƒä¸‹é¢ä¸€æ ·ç›´æ¥ . å»æ‹¿å³å¯ï¼‰
    e->n = 0;
    e->x = 0.0f; // ç»™ float åŠ  f å¦åˆ™æ•°å­—é»˜è®¤æ˜¯ double ä¼šæœ‰ä¸€æ¬¡éšå¼è½¬æ¢
}
/**
 * @brief Reset fields of essai to zero (pass by reference)
 * @param e Reference to essai struct
 */
void raz(struct essai &e) noexcept
{
    e.n = 0;
    e.x = 0.0f;
}

int main()
{
    essai E{100, -100.0f};
    std::cout << "--é€šè¿‡æŒ‡é’ˆé‡ç½®å‰å¯¹è±¡ä¸­çš„n,xå€¼:" << E.n << ',' << E.x << std::endl;
    raz(&E);
    std::cout << "--é€šè¿‡æŒ‡é’ˆé‡ç½®åå¯¹è±¡ä¸­çš„n,xå€¼:" << E.n << ',' << E.x << std::endl;

    // ----------
    E = {-100, 100.0f}; // ç­‰ä»·äºä¸‹é¢ä¸¤å¥
    // E.n = -100;
    // E.x = 100.0f;
    std::cout << "--é€šè¿‡å¼•ç”¨é‡ç½®å‰å¯¹è±¡ä¸­çš„n,xå€¼:" << E.n << ',' << E.x << std::endl;
    raz(E);
    std::cout << "--é€šè¿‡å¼•ç”¨é‡ç½®åå¯¹è±¡ä¸­çš„n,xå€¼:" << E.n << ',' << E.x << std::endl;

    return 0;
}
```


# Ex14 æ–‡ä»¶å¤¹
## dec.h
```h
#ifndef DEC_H
#define DEC_H

// #include <optional>

struct point
{
    int x;
    int y;
    int z;

    // é»˜è®¤æ„é€ å‡½æ•°ï¼ˆä¸å†™ä¹Ÿé»˜è®¤ï¼‰
    point() : x(0), y(0), z(0) {}

    // å¯é€‰å‚æ•°æ„é€ å‡½æ•°
    point(int xVal, int yVal = 0, int zVal = 0)
        : x(xVal), y(yVal), z(zVal) {}

    // æ³•2: é€šè¿‡æˆå‘˜å‡½æ•°ï¼šé‡ç½®
    void reset(int a = 0, int b = 0, int c = 0)
    {
        x = a;
        y = b;
        z = c;
    }
};

// æ³•1: è¿™é“é¢˜æƒ³è¦å®ç°å¤šå‚æ•°çš„åˆå§‹åŒ–ï¼Œç¬¬ä¸€æƒ³æ³•å°±æ˜¯é€šè¿‡å¯é€‰å‚æ•°ï¼ŒåƒJSä¸­å¯ä»¥ç›´æ¥é€šè¿‡ ?: æ¥å®ç°ï¼Œ
// C++çš„è¯å¯ä»¥é€šè¿‡è®¾ç½®é»˜è®¤å‚æ•°æ¥é™çº§å®ç°ï¼Œæˆ–è€…åˆ©ç”¨ std::optional æ¥å®ç°ï¼ˆæ³¨æ„éœ€è¦ C++17 upï¼‰
// void init(point *p, std::optional<int> x = std::nullopt, std::optional<int> y = std::nullopt, std::optional<int> z = std::nullopt);
void init(point *p, int x = 0, int y = 0, int z = 0) noexcept;

#endif
```

## init.cpp
```cpp
#include "dec.h"

void init(point *p, int x, int y, int z) noexcept // æ³¨æ„åœ¨å£°æ˜çš„æ—¶å€™å†™äº†é»˜è®¤å‚æ•°ååœ¨å®šä¹‰ä¸éœ€è¦å†å†™ä¸€é
{
    p->x = x;
    p->y = y;
    p->z = z;
}
```

## main.cpp
```cpp
#include "dec.h"
#include <iostream>

int main()
{
    point p{100, 200, 300};
    std::cout << "--é‡ç½®xä¸º1000å‰x,y,zå€¼: " << p.x << ',' << p.y << ',' << p.z << std::endl;
    init(&p, 1000);
    std::cout << "--é‡ç½®åx,y,zå€¼: " << p.x << ',' << p.y << ',' << p.z << std::endl;
    std::cout << '\n';

    p = {100, 200, 300};
    std::cout << "--é‡ç½®xä¸º1000ã€yä¸º2000å‰x,y,zå€¼: " << p.x << ',' << p.y << ',' << p.z << std::endl;
    init(&p, 1000, 2000);
    std::cout << "--é‡ç½®åx,y,zå€¼: " << p.x << ',' << p.y << ',' << p.z << std::endl;
    std::cout << '\n';

    p = {100, 200, 300};
    std::cout << "--é‡ç½®xä¸º1000ã€yä¸º2000ã€zä¸º3000å‰x,y,zå€¼: " << p.x << ',' << p.y << ',' << p.z << std::endl;
    init(&p, 1000, 2000, 3000);
    std::cout << "--é‡ç½®åx,y,zå€¼: " << p.x << ',' << p.y << ',' << p.z << std::endl;
    std::cout << '\n';

    //----------------
    point p2(100, 200, 300);
    std::cout << "--æ³•2é€šè¿‡æˆå‘˜å‡½æ•°é‡ç½®xä¸º1000ã€yä¸º2000ã€zä¸º3000å‰x,y,zå€¼: " << p2.x << ',' << p2.y << ',' << p2.z << std::endl;
    p2.reset(1000, 2000, 3000);
    std::cout << "--é‡ç½®åx,y,zå€¼: " << p2.x << ',' << p2.y << ',' << p2.z << std::endl;

    return 0;
}
```


# Ex14
```cpp
/*
è¿™é“é¢˜ä¸»è¦è€ƒå¯Ÿå¤šå‚æ•°çš„ç»“æ„ä½“é‡ç½®ï¼Œè¯¦æƒ…çœ‹ Ex14 æ–‡ä»¶å¤¹
*/
```


# Ex15
```cpp
#include <iostream>

/*
è€ƒå¯Ÿå†…å­˜ç®¡ç†
C++ä¸­ new åªéœ€è¦çŸ¥é“ç±»å‹ï¼Œä¸éœ€è¦sizeofå»æ‹¿åˆ°å†…å­˜è¯¥ç±»å‹çš„å¤§å°å†å‘ŠçŸ¥ mallocï¼›æ¸…ç†çš„è¯ä» C çš„ free å˜æˆäº† deleteï¼ˆå¦‚æœæ˜¯æ•°ç»„çš„è¯è¿˜å¾—åŠ ä¸Š[]ï¼‰
*/

void essai_alloc()
{
    int *pt_int = new int;
    double *pt_double = new double[100];

    pt_double[0] = 1.0;
    pt_double[1] = 2.0;
    std::cout << "--åˆ é™¤å‰æ•°ç»„å†…å®¹" << *pt_double << std::endl;

    delete pt_int;
    delete[] pt_double;

    // ä¸Šé¢ delete æ‚¬ç©ºåä¸‹é¢è¾“å‡ºçš„æ˜¯å­˜æ®‹ç•™ä½æ¨¡å¼æŒ‰ double è§£é‡Šäº§ç”Ÿçš„â€œåƒåœ¾å€¼â€
    std::cout << "--åˆ é™¤åæ•°ç»„å†…å®¹" << *pt_double << std::endl;
}

int main()
{
    essai_alloc();

    return 0;
}
```


# Ex16
```cpp
#include <stdio.h>
#include <iostream> // æ€§èƒ½æ¯”stdioæ›´ä½³ä½†æ˜¯æ ¼å¼åŒ–æ¯”è¾ƒéº»çƒ¦
struct personne
{
    char nom[30];
    unsigned int age;
};

void raz(struct personne *p)
{
    p->nom[0] = '\0'; // ç›´æ¥åœ¨å­—ç¬¦ä¸²æ•°ç»„ç¬¬ä¸€ä¸ªè®¾ç½®ç»ˆæ­¢ç¬¦å·å³å¯ä¼˜é›…æ¸…ç©º
    p->age = 0;
}

void affiche_struct(const struct personne *p)
{
    // if (p->nom[0] != '\0')
    // {
    printf("Nom : %s, Age : %u\n", p->nom, p->age);
    // }
    // else
    // {
    //     printf("Nom : Null, Age : %u\n", p->age);
    // }
}

void affiche_tab(const struct personne *p, int n = -1) // ä¼ p[]ä¼šè‡ªåŠ¨é€€åŒ–ä¸ºæŒ‡å‘é¦–å…ƒç´ çš„æŒ‡é’ˆ
{
    if (n == -1)
    {
        // n = sizeof(*p); è¿™æ ·æ‹¿åˆ°çš„åªæ˜¯é¦–å…ƒç´ çš„å¤§å°ï¼ŒC++æ— æ³•æ¨æµ‹æ•°ç»„çš„ç»“æŸï¼ˆé™¤éç”¨ vector æˆ–è€…æœ‰æ ‡è¯†ç¬¦ï¼‰
        std::cout << "è¯·ä¼ å…¥æ•°ç»„é•¿åº¦" << std::endl;
    }
    for (int i = 0; i < n; i++)
    {
        affiche_struct(&p[i]);
    }
}

// è¿™ä¸ªå‡½æ•°ä¹Ÿå¯ä»¥ç›´æ¥å†™åœ¨ struct é‡Œé¢ä½œä¸ºæ„é€ å‡½æ•°ï¼ˆå‡½æ•°åå¿…é¡»è¦å’Œç»“æ„ä½“åç›¸åŒï¼Œè€Œä¸”æ³¨æ„è®¾ç½®é»˜è®¤å€¼ï¼‰
void init_struct(struct personne *p, const char *name, unsigned int age)
{
    // é¢˜ç›®è¦æ±‚ä¸èƒ½ç”¨ strcpy å‡½æ•°ï¼Œä¸”å­—ç¬¦ä¸²æ˜¯ç”¨ char[] å°±åªèƒ½ä¸€ä¸ªä¸ªå¾ªç¯è¿‡å»è¿ç§»
    int i = 0;
    while (name[i] != '\0' && i < 29)
    {
        p->nom[i] = name[i];
        i++;
    }
    p->nom[i] = '\0';
    p->age = age;
}

void copy_struct(const struct personne *src, struct personne *dest)
{
    // ç”±äºç”¨çš„ char[] æ‰€ä»¥å¾—è§£æ„èµ‹å€¼ï¼Œstring çš„è¯ç›´æ¥ = å³å¯
    int i = 0;
    while (src->nom[i] != '\0' && i < 29)
    {
        dest->nom[i] = src->nom[i];
        i++;
    }
    dest->nom[i] = '\0';
    dest->age = src->age;
}

void copy_tab(const struct personne *src, struct personne *dest, int n)
{
    for (int i = 0; i < n; i++)
    {
        copy_struct(&src[i], &dest[i]);
    }
}

int main()
{
    struct personne a, b;
    struct personne tab1[2];
    struct personne tab2[2];

    init_struct(&a, "Alice", 20);
    init_struct(&b, "Bob", 25);

    printf("== init_struct + affiche_struct ==\n");
    affiche_struct(&a);
    affiche_struct(&b);

    printf("\n== raz ==\n");
    raz(&a);
    affiche_struct(&a);

    init_struct(&tab1[0], "Charlie", 22);
    init_struct(&tab1[1], "David", 30);

    printf("\n== affiche_tab ==\n");
    affiche_tab(tab1, 2);

    printf("\n== copy_tab ==\n");
    copy_tab(tab1, tab2, 2);
    affiche_tab(tab2, 2);
}
```


# Ex17
```cpp
#include <string>
#include <iostream>

// é¢˜ç›®è¦æ±‚åœ¨ 16 çš„åŸºç¡€ä¸Šç”¨æ›´ä¼˜é›…çš„ stringï¼Œä¸”æˆ‘è¿›ä¸€æ­¥ç”¨ 16 ä¸­æåˆ°çš„å†…ç½®å‡½æ•°å†™æ³•ï¼Œå¦‚æœä¸ä¹ æƒ¯çš„åªéœ€è¦å°† 16 ä¸­çš„ char éƒ½æ›¿æ¢ä¸º std::string å³å¯ï¼ŒåŒæ—¶ä¸éœ€è¦å¾ªç¯èµ‹å€¼å­—ç¬¦ä¸²ã€ç›´æ¥ = å³å¯,ä»¥åŠå­—ç¬¦ä¸²çš„æ¸…é™¤ clear() API

struct personne
{
    std::string nom;
    unsigned int age;

    // é»˜è®¤æ„é€  + å¸¦å‚æ„é€ 
    personne(const std::string &name = "", unsigned int a = 0)
        : nom(name), age(a) {}

    // æ¸…ç©º
    void raz()
    {
        nom.clear(); //
        age = 0;
    }

    // è¾“å‡ºè‡ªèº«ä¿¡æ¯
    void affiche() const
    {
        std::cout << "Nom : " << nom << ", Age : " << age << std::endl;
    }
};

// æ‰“å°æ•°ç»„
void affiche_tab(const personne *p, int n)
{
    for (int i = 0; i < n; i++)
        p[i].affiche();
}

// å¤åˆ¶æ•°ç»„
void copy_tab(const personne *src, personne *dest, int n)
{
    for (int i = 0; i < n; i++)
        dest[i] = src[i];
}

int main()
{
    personne a("Alice", 20);
    personne b("Bob", 25);

    std::cout << "== constructeur + affiche ==\n";
    a.affiche();
    b.affiche();

    std::cout << "\n== raz ==\n";
    a.raz();
    a.affiche();

    personne tab1[2] = {personne("Charlie", 22), personne("David", 30)};
    personne tab2[2];

    std::cout << "\n== affiche_tab ==\n";
    affiche_tab(tab1, 2);

    std::cout << "\n== copy_tab ==\n";
    copy_tab(tab1, tab2, 2);
    affiche_tab(tab2, 2);

    return 0;
}```


# Ex17Pro æ–‡ä»¶å¤¹
## Person.hpp
```h
#ifndef PERSON_HPP
#define PERSON_HPP

#include <string>
#include <iostream>

// ä¸ªä½“ç®¡ç†

class Person
{
private:
    std::string name_; // å˜é‡åååŠ  _ ç”¨äºè¡¨ç¤ºè¿™æ˜¯ç±»çš„æˆå‘˜å˜é‡ï¼ˆé˜²æ­¢é‡åï¼‰
    unsigned int age_;

public:
    Person(std::string name = "", unsigned int age = 0)
        : name_(std::move(name)), age_(age) {}

    // ç”±äºæœ¬ä»£ç ä¸­çš„æˆå‘˜å±æ€§æ˜¯ç§æœ‰çš„ï¼Œè€Œå¤–éƒ¨éœ€è¦æ‰“å°ï¼Œå°±åƒå¤–æš´éœ² getter å‡½æ•°
    const std::string &name() const { return name_; } // é€šè¿‡ const ç¡®ä¿å®‰å…¨æ€§
    unsigned int age() const { return age_; }

    void reset()
    {
        name_.clear(); // string ç›´æ¥ clear å³å¯
        age_ = 0;
    }

    // é‡è½½è¿ç®—ç¬¦ï¼šoperatoråŠ è¿ç®—ç¬¦
    friend std::ostream &operator<<(std::ostream &os, const Person &p) // osä»¥éå¸¸é‡å¼•ç”¨æ¥å—è¾“å‡ºæµ
    // friend è¡¨ç¤ºè¯¥å‡½æ•°æ˜¯ç±»çš„æœ‹å‹å°±èƒ½ç›´æ¥è®¿é—®ç±»çš„ç§æœ‰æˆå‘˜äº†
    {
        return os << p.name_ << " (" << p.age_ << ")";
        // åˆ©ç”¨é‡è½½è¾“å‡ºè¿ç®—ç›´æ¥è¿”å›æ•°æ®æµï¼Œè°ƒç”¨è¯¥å‡½æ•°çš„æ—¶å€™ç›´æ¥æ¥åˆ° std::cout ä¸Šå³å¯
    }
};

#endif```

## PersonManager.hpp
```h
#ifndef PERSONMANAGER_HPP
#define PERSONMANAGER_HPP

#include "Person.hpp"
#include <vector>

// å¤šä¸ªä½“æ•°ç»„ç®¡ç†

class PersonManager
{
private:
    std::vector<Person> persons_;

public:
    // å¦‚æœæ’å…¥å·²æœ‰å¯¹è±¡ç”¨ push_back ï¼›ç›´æ¥ä¼ å‚æ•°ç”¨ emplace_back
    void add(const Person &p)
    {
        persons_.push_back(p); // vector ç”¨ push_back åŠ¨æ€ç®¡ç†æ•°ç»„
    }

    template <typename... Args>  // å¯å˜å‚æ•°æ¨¡ç‰ˆï¼Œè¡¨ç¤ºå¯ä»¥æ¥å—ä»»æ„æ•°é‡ã€ä»»æ„ç±»å‹çš„å‚æ•°
    void emplace(Args &&...args) // &&æ˜¯ä¸‡èƒ½å¼•ç”¨ï¼Œ... å’ŒJSä¸€æ ·éƒ½ç”¨äºå±•å¼€
    {
        persons_.emplace_back(std::forward<Args>(args)...);
        /*
        emplace_back æ˜¯vectoræ›´é«˜æ•ˆçš„æ’å…¥æ–¹å¼ï¼Œ
        ç›´æ¥åœ¨å®¹å™¨å†…éƒ¨åŸåœ°æ„é€ å¯¹è±¡ï¼Œè€Œä¸æ˜¯å…ˆæ„é€ ä¸€ä¸ªå¯¹è±¡å†ç§»åŠ¨è¿›å»
        */
    }

    void clear()
    {
        persons_.clear();
    }

    void print() const
    {
        if (!persons_.size())
        {
            std::cout << "== Null == NoBody ==" << std::endl;
            return;
        }
        for (const auto &p : persons_)
        {
            std::cout << p << std::endl;
        }
    }
};

#endif```

## main.cpp
```cpp
#include "PersonManager.hpp"

int main()
{
    PersonManager pm;

    pm.emplace("Alice", 20);
    pm.emplace("Bob", 25);
    pm.add(Person("Bobby", 100));

    std::cout << "== People List ==" << std::endl;
    pm.print();

    std::cout << "\n== After reset ==" << std::endl;
    pm.clear();
    pm.print();

    return 0;
}
```


# Ex17Pro
```cpp
/*
é€‰çœ‹
ä½†æ˜¯ 17 è¿˜æ˜¯ä¸å¤Ÿä¼˜é›…å’Œç°åœ¨ï¼Œ
æœ€å¥½æ˜¯ç”¨ vector å¹¶ç»“åˆ é¢å‘å¯¹è±¡OOP èŒƒå¼ï¼Œå°†æ•°æ® & è¡Œä¸ºä¸€ä½“åŒ–
è¯¦æƒ…è¯·çœ‹ Ex17Pro æ–‡ä»¶å¤¹
*/
```


# Ex18
```cpp
#include <string>
#include <iostream>
struct compte
{
    std::string id;
    int solde;
};

// æ³¨æ„å‡½æ•°å¾—è¿”å›å¼•ç”¨ & å¦åˆ™åç»­ä¸èƒ½å¯¹è¿”å›è¿›è¡Œæ“ä½œ
int &operation(struct compte *p, std::string id, int n)
{
    for (int i = 0; i < n; i++) // é¢˜ç›®è¦æ±‚ï¼Œå¦åˆ™ç”¨ map + contains åˆ¤æ–­æ›´å¿«
        if (p[i].id == id)
            return p[i].solde; // å½“å‡½æ•°ç­¾åæœ‰ & æ—¶è¿”å›æ•°ç»„[i]æ˜¯ç›´æ¥è¿”å›çš„å¼•ç”¨
                               // å‡½æ•°å†…éƒ¨ä¸éœ€è¦æ“ä½œï¼Œç›´æ¥è¿”å›å°±å¥½

    throw std::runtime_error("Not found!");
};

int main()
{
    compte tab[4] = {{"courant", 0}, {"codevi", 1500}, {"epargne", 200}, {"cel", 300}};
    std::cout << "== æ“ä½œå‰å„è´¦æˆ·æ•°æ® ==\n";
    for (int i = 0; i < 4; i++)
        std::cout << tab[i].id << " : " << tab[i].solde << "\n";

    operation(tab, "courant", 4) = 100; // courant è´¦æˆ·ä½™é¢è®¾ä¸º 100
    operation(tab, "codevi", 4) += 100; // codevi è´¦æˆ·ä½™é¢ +100
    operation(tab, "cel", 4) -= 50;     // cel è´¦æˆ·ä½™é¢ -50

    std::cout << "\n== æ“ä½œåå„è´¦æˆ·æ•°æ® ==\n";
    for (int i = 0; i < 4; i++)
        std::cout << tab[i].id << " : " << tab[i].solde << "\n";

    std::cout << "\n== å°è¯•ä¸å­˜åœ¨çš„key ==\n";
    operation(tab, "ceilf6", 4) += 10000;
    std::cout << "\n== æ“ä½œåå„è´¦æˆ·æ•°æ® ==\n";
    for (int i = 0; i < 4; i++)
        std::cout << tab[i].id << " : " << tab[i].solde << "\n";

    return 0;
}
```


# Ex19
```cpp
/*
çŸ¥è¯†ç‚¹ï¼š
ææ„
ç±»çš„å­¦ä¹ 

ææ„çœ‹èµ·æ¥æœ‰ç‚¹åƒåƒåœ¾å›æ”¶æœºåˆ¶ä½†ä¸¤è€…æ˜¯ä¸ä¸€æ ·çš„
åƒåœ¾å›æ”¶æœºåˆ¶æ˜¯è‡ªåŠ¨ç®¡ç†å †å†…å­˜è¿›è¡Œå›æ”¶çš„ï¼Œä¾‹å¦‚åœ¨JSä¸­ä½“ç°ä¸ºé—­åŒ…å»¶é•¿ç”Ÿå‘½å‘¨æœŸï¼Œå®ç°é˜²æŠ–èŠ‚æµç­‰ç­‰

è€Œåœ¨C++ä¸­
å½“æ ˆå†…å­˜çš„å¯¹è±¡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨ææ„å‡½æ•°ï¼Œä¸”ç”±ç¼–è¯‘å™¨è‡ªåŠ¨popå¼¹å‡ºå†…å­˜ç©ºé—´
è€Œå †å†…å­˜ï¼ˆnewå®ä¾‹ï¼‰æ˜¯åœ¨æ‰§è¡Œ delete çš„æ—¶å€™ä¼šè°ƒç”¨ææ„å‡½æ•°ï¼Œç„¶åé‡Šæ”¾å †å†…å­˜
æ‰€ä»¥ææ„å‡½æ•°ä¸ç®¡ç†å†…å­˜ï¼Œè€Œæ˜¯ç®¡ç†è¯¥å¯¹è±¡æ‹¥æœ‰çš„å¤–éƒ¨èµ„æºï¼Œå®ƒæ˜¯ RAIIèµ„æºè·å–å³åˆå§‹åŒ– çš„ä¸€éƒ¨åˆ†ï¼Œç”¨äºå¯¹è±¡ç”Ÿå‘½å‘¨æœŸç»“æŸçš„ç¬é—´ï¼Œä¾‹å¦‚é‡Šæ”¾æ•°ç»„ã€å…³é—­æ–‡ä»¶ã€é‡Šæ”¾äº’æ–¥é”ç­‰ç­‰

è¯¦æƒ…è¯·çœ‹ Ex19 æ–‡ä»¶å¤¹
*/
```


# Ex19&20&21 æ–‡ä»¶å¤¹
## fraction.hpp
```h
#ifndef FRACTION_H
#define FRACTION_H

#include <iostream>
#include "fractionException.hpp"

namespace MATH
{
    class Fraction
    {
    private:
        int numerateur_;
        int denominateur_;
        void simplification(); // ç§æœ‰åŒ–ç®€å‡½æ•°

    public:
        // é‡è½½æ„é€ å‡½æ•°
        Fraction(int n = 0, int d = 1); // é»˜è®¤å€¼æ„é€ 
        Fraction(const Fraction &f);    // æ‹·è´æ„é€ 

        ~Fraction();

        // ç§æœ‰å±æ€§getterå‡½æ•°
        // getter å‡½æ•°æ¨èå†™æˆ inline ï¼Œé¦–å…ˆgetteråªéœ€è¦è¿”å›å±æ€§å€¼å³å¯å¼€é”€å¾ˆå°ï¼Œè€Œä¸”å¤§é¡¹ç›®ä¸­ç±»ä¸€èˆ¬ä¼šåœ¨å¤šå¤„å¤ç”¨
        inline int getNumerateur() const { return numerateur_; }
        inline int getDenominateur() const { return denominateur_; }

        // setter å‡½æ•°ï¼Œä¿®æ”¹ç§æœ‰å±æ€§
        void setFraction(int n, int d);

        // åŠ æ³•
        Fraction somme(const Fraction &f) const;

        // è¾“å‡º
        void afficher() const;
    };
}

#endif
```

## fractionException.hpp
```h
#ifndef FRACTION_EXCEPTION_HPP
#define FRACTION_EXCEPTION_HPP

#include <cstring>

// å‰å‘å£°æ˜ï¼Œé¿å…å¾ªç¯ä¾èµ–ï¼ˆç”¨äºä¸‹é¢è®¾ç½® badValue ï¼‰
namespace MATH
{
    class Fraction; // å‰å‘å£°æ˜
}

// è‡ªå®šä¹‰å¼‚å¸¸ç±»ä»è€Œä¸ªæ€§åŒ–ã€ç²¾å‡†çš„åŒºåˆ†é”™è¯¯
// ä¾‹å¦‚æœ¬é¢˜åªéœ€è¦è¾“å‡ºé”™è¯¯ä¿¡æ¯å­—ç¬¦ä¸²å°±å¥½ï¼Œä½†æ˜¯ç°åœ¨æˆ‘æœ‰éœ€è¦å¾—åˆ°æŠ¥é”™çš„æ¥æºå¯¹è±¡ï¼Œäºæ˜¯æˆ‘å¯ä»¥åŠ ä¸€ä¸ª badValue

namespace MATH
{
    class FractionException
    {
    private:
        char info_[256];
        int numerateur_;   // åˆ†å­
        int denominateur_; // åˆ†æ¯

    public:
        // é¢˜ç›®åŸºæœ¬è¦æ±‚ï¼šæ¥å—å­—ç¬¦ä¸²åˆ›å»ºå¼‚å¸¸å¯¹è±¡
        FractionException(const char *message)
            : numerateur_(0), denominateur_(1)
        {
            strncpy(info_, message, 255);
            info_[255] = '\0'; // ç¡®ä¿å­—ç¬¦ä¸²ä»¥ null ç»“å°¾
        }

        // è¿›é˜¶ä¸ªæ€§åŒ–ï¼šåœ¨åŸºç¡€ä¸Šæ¥æ”¶åˆ†æ•°å€¼åˆ›å»ºå¼‚å¸¸å¯¹è±¡
        FractionException(const char *message, int n, int d)
            : numerateur_(n), denominateur_(d)
        {
            strncpy(info_, message, 255);
            info_[255] = '\0';
        }

        // è·å–é”™è¯¯ä¿¡æ¯
        const char *getInfo() const
        {
            return info_;
        }

        // è·å–å¯¼è‡´å¼‚å¸¸çš„åˆ†å­
        int getNumerateur() const
        {
            return numerateur_;
        }

        // è·å–å¯¼è‡´å¼‚å¸¸çš„åˆ†æ¯
        int getDenominateur() const
        {
            return denominateur_;
        }
    };
}

#endif
```

## fractionPatch.hpp
```h
#ifndef FRACTION_PATCH_H
#define FRACTION_PATCH_H

#include "fraction.hpp"
#include <iostream>

namespace MATH
{
    Fraction operator+(const Fraction &f1, const Fraction &f2);

    Fraction operator+(const Fraction &f, int n);
    Fraction operator+(int n, const Fraction &f);

    // å‰ç¼€ç‰ˆæœ¬ ++f (è¿”å›å¼•ç”¨ï¼Œå› ä¸ºè¿”å›è‡ªèº«)
    Fraction &operator++(Fraction &f);
    // åç¼€ç‰ˆæœ¬ f++ (å‚æ•° int æ˜¯å“‘å…ƒï¼Œç”¨äºé‡è½½)
    Fraction operator++(Fraction &f, int); // å½“ç¼–è¯‘å™¨çœ‹åˆ° ++ åœ¨åé¢çš„æ—¶å€™ï¼Œå®é™…è°ƒç”¨çš„æ˜¯ operator++(f, 0) ä»è€ŒåŒºåˆ†å‰åç¼€

    std::ostream &operator<<(std::ostream &os, const Fraction &f);
}

#endif
```

## fraction.cpp
```cpp
#include "fraction.hpp"

// C++çš„this å’Œ pyçš„self æ›´åƒï¼Œæ˜¯æŒ‡å‘å½“å‰å¯¹è±¡çš„æŒ‡é’ˆã€å†…å­˜åœ°å€
// ï¼ˆåªä¸è¿‡ pyçš„self æ›´åŠ æ˜¾å¼ï¼‰ï¼ˆå’Œ JSçš„this å·®è¿œï¼ŒJSçš„thisçš„å››æ¡è§„åˆ™æ›´åŠ åŠ¨æ€ï¼‰

namespace MATH // namespace ä¸æ˜¯å…¨å±€ç”Ÿæ•ˆæ‰€ä»¥å¦‚æœç©ºé—´åˆ†æ•£åœ¨å¤šå¤„çš„è¯å¾—å¤šæ¬¡ namespace
{
    // ç±»ä¹Ÿæ˜¯ä¸€ç§ä½œç”¨åŸŸï¼Œåƒ namespace ä¸€æ ·éœ€è¦ :: æ¥è®¿é—®
    // è¿™æ ·å°±å‘Šè¯‰äº†ç¼–è¯‘å™¨ è¿™ä¸ªå‡½æ•°æ˜¯å±äºç±»çš„
    Fraction::Fraction(int n, int d) : numerateur_(n), denominateur_(d)
    // ç±»çš„æˆå‘˜å(å‚æ•°) ï¼šå°†å‚æ•°èµ‹å€¼ç»™ç±»çš„æˆå‘˜
    {
        std::cout << "+ æ„é€  Fraction å¯¹è±¡: " << this << " => "
                  << numerateur_ << "/" << denominateur_ << std::endl;
        simplification();
    }
    // æ‹·è´æ„é€ 
    Fraction::Fraction(const Fraction &f)
        : numerateur_(f.numerateur_), denominateur_(f.denominateur_)
    {
        std::cout << "+ æ‹·è´æ„é€  Fraction: " << this << " <= " << &f << std::endl;
    }

    // ~åŠ ç±»åï¼šææ„å‡½æ•°ï¼Œå½“æ ˆå†…å­˜çš„å¯¹è±¡ç¦»å¼€ä½œç”¨åŸŸæ—¶æˆ–è€…å †å†…å­˜å¯¹è±¡deleteæ—¶è‡ªåŠ¨è°ƒç”¨
    Fraction::~Fraction()
    {
        // Fraction ç±»æ²¡æœ‰æˆ‘åœ¨ Ex19 ä¸­æåˆ°çš„æ•°ç»„ã€æ–‡ä»¶ã€äº’æ–¥é”ç­‰ï¼Œæ‰€ä»¥ Fraction ç±»çš„ææ„å‡½æ•°åªç”¨äºå±•ç¤º
        std::cout << "- ææ„ Fraction å¯¹è±¡: " << this << " => "
                  << numerateur_ << "/" << denominateur_ << std::endl;
    }

    // setter
    void Fraction::setFraction(int n, int d)
    {
        numerateur_ = n;
        denominateur_ = d;
        simplification();
    }

    // ç®€åŒ–å‡½æ•°
    void Fraction::simplification()
    {
        // ç”±äºæ‰€æœ‰æ„é€ ä»¥åŠæ“ä½œåéƒ½ä¼šæ±‡æ€»åˆ°ç®€åŒ–å‡½æ•°ï¼Œæ‰€ä»¥åœ¨ç®€åŒ–å‡½æ•°é‡Œé¢å¤„ç†å¼‚å¸¸å°±èƒ½å®ç°å¹¿è¦†ç›–
        if (denominateur_ == 0)
        {
            // throw ä¹‹åçš„ä»£ç ä¸ä¼šæ‰§è¡Œï¼Œå› ä¸ºç¨‹åºæµç¨‹ç«‹å³è·³è½¬åˆ° catch å—
            throw FractionException("é”™è¯¯ï¼šåˆ†æ¯ä¸èƒ½ä¸º0ï¼", numerateur_, denominateur_);
        }

        if (numerateur_ == 0)
        {
            denominateur_ = 1;
            return;
        }

        int a = (numerateur_ > 0) ? numerateur_ : -numerateur_;
        int b = (denominateur_ > 0) ? denominateur_ : -denominateur_;

        /*
        // é€šè¿‡æ¬§å‡ é‡Œå¾—ç®—æ³•æ‰¾æœ€å¤§å…¬çº¦æ•°
        while (a != b)
        {
            if (a > b)
                a -= b;
            else
                b -= a;
        }
        */
        // è¾—è½¬å–ä½™æ³•æ›´å¿«
        while (b != 0)
        {
            int temp = b;
            b = a % b;
            a = temp;
        }

        numerateur_ /= a;
        denominateur_ /= a;

        if (denominateur_ < 0)
        {
            denominateur_ = -denominateur_;
            numerateur_ = -numerateur_;
        }
    }

    // åŠ æ³•
    Fraction Fraction::somme(const Fraction &f) const
    {
        return Fraction(
            numerateur_ * f.denominateur_ + denominateur_ * f.numerateur_,
            denominateur_ * f.denominateur_);
        // è¿™é‡Œä¸éœ€è¦ç®€åŒ–ï¼Œå› ä¸º Fraction æ„é€ å‡½æ•°å†…éƒ¨æœ€åä¼šè°ƒç”¨
    }

    // å±•ç¤º
    void Fraction::afficher() const
    {
        std::cout << numerateur_ << "/" << denominateur_;
    }
}
```

## fractionPatch.cpp
```cpp
#include "fractionPatch.hpp"

namespace MATH
{
    Fraction operator+(const Fraction &f1, const Fraction &f2)
    {
        // åˆ©ç”¨å·²æœ‰çš„ somme æ–¹æ³•
        return f1.somme(f2);

        // æˆ–è€…ç›´æ¥å®ç°ï¼š
        // return Fraction(
        //     f1.getNumerateur() * f2.getDenominateur() +
        //     f1.getDenominateur() * f2.getNumerateur(),
        //     f1.getDenominateur() * f2.getDenominateur()
        // );
    }

    Fraction operator+(const Fraction &f, int n)
    {
        // int n å¯ä»¥çœ‹ä½œ n/1
        return Fraction(
            f.getNumerateur() + n * f.getDenominateur(),
            f.getDenominateur());
    }

    Fraction operator+(int n, const Fraction &f)
    {
        // åŠ æ³•æ»¡è¶³äº¤æ¢å¾‹ï¼Œç›´æ¥è°ƒç”¨ä¸Šé¢çš„å‡½æ•°
        return f + n;
    }

    // å‰ç¼€ç‰ˆæœ¬ï¼šå…ˆé€’å¢ï¼Œå†è¿”å›
    Fraction &operator++(Fraction &f)
    {
        // åˆ†å­åŠ ä¸Šåˆ†æ¯ï¼Œç›¸å½“äº +1
        f.setFraction(
            f.getNumerateur() + f.getDenominateur(),
            f.getDenominateur());
        return f;
    }

    // åç¼€ç‰ˆæœ¬ï¼šå…ˆè¿”å›æ—§å€¼ï¼Œå†é€’å¢ï¼ˆç”±ä¸‹é¢å¯ä»¥çœ‹å‡ºéœ€è¦æ‹·è´æ„é€ å¹¶ææ„ä¸´æ—¶å¯¹è±¡ï¼Œè¿‡æ…¢ï¼Œæ‰€ä»¥å®é™…è¿˜æ˜¯æ¨èå‰ç¼€++ï¼‰
    Fraction operator++(Fraction &f, int)
    {
        // ä¿å­˜å½“å‰å€¼
        Fraction temp(f);

        // é€’å¢å½“å‰å¯¹è±¡
        ++f; // è°ƒç”¨å‰ç¼€ç‰ˆæœ¬

        // è¿”å›æ—§å€¼
        return temp;
    }

    std::ostream &operator<<(std::ostream &os, const Fraction &f)
    {
        os << f.getNumerateur() << "/" << f.getDenominateur();
        return os; // è¿”å›æµå¼•ç”¨ï¼Œæ”¯æŒé“¾å¼è°ƒç”¨å¦‚ cout << f1 << f2
    }
}
```

## main.cpp
```cpp
#include <iostream>
#include "fraction.hpp"
#include "fractionPatch.hpp"

using namespace std;
using namespace MATH;

Fraction *myFunction()
{
    Fraction fx(7, 8);
    Fraction *pfy = new Fraction(2, 3);
    return pfy;
}

int main()
{
    Fraction f1(3, 4);
    Fraction f2(1, 6);
    Fraction *pf3 = new Fraction(1, 2);

    cout << "\n---- è¿›å…¥ä¸€ä¸ªä½œç”¨åŸŸ ----\n";
    Fraction *pf6;
    {
        Fraction f4(3, 8);
        Fraction f5(4, 6);
        pf6 = new Fraction(1, 3);
    }
    cout << "---- ç¦»å¼€ä½œç”¨åŸŸ ----\n";

    // å‡½æ•°ä½œç”¨åŸŸ
    cout << "\n---- è¿›å…¥å‡½æ•° ----\n";
    Fraction *pf7 = myFunction();
    cout << "---- ç¦»å¼€å‡½æ•° ----\n";

    cout << "\n---- æ‰‹åŠ¨é‡Šæ”¾å†…å­˜ ----\n";
    delete pf6;
    delete pf7;
    delete pf3;

    cout << "\n---- æµ‹è¯•åŠ æ³• ----\n";
    cout << f1.getNumerateur() << '/' << f1.getDenominateur() << " + " << f2.getNumerateur() << '/' << f2.getDenominateur() << endl;
    Fraction r = f1.somme(f2);
    r.afficher();
    cout << endl;

    // Ex20 =================================

    cout << "\n==== E20 - æµ‹è¯•è¿ç®—ç¬¦é‡è½½ ====\n";
    cout << "\n---- æµ‹è¯• f1 + f2 (Fraction + Fraction) ----\n";
    Fraction f8(1, 2);
    Fraction f9(1, 3);
    cout << "f8 = " << f8 << ", f9 = " << f9 << endl;
    Fraction f10 = f8 + f9;
    cout << "f8 + f9 = " << f10 << endl;

    cout << "\n---- æµ‹è¯• Fraction + int å’Œ int + Fraction ----\n";
    Fraction f11(2, 3);
    cout << "f11 = " << f11 << endl;
    Fraction f12 = f11 + 2;
    cout << "f11 + 2 = " << f12 << endl;
    Fraction f13 = 3 + f11;
    cout << "3 + f11 = " << f13 << endl;

    cout << "\n---- æµ‹è¯• ++f å’Œ f++ ----\n";
    Fraction f14(3, 4);
    cout << "åŸå§‹å€¼ f14 = " << f14 << endl;

    cout << "å‰ç¼€ ++f14 = " << ++f14 << endl;
    cout << "æ‰§è¡Œå f14 = " << f14 << endl;

    Fraction f15(5, 6);
    cout << "\nåŸå§‹å€¼ f15 = " << f15 << endl;
    cout << "åç¼€ f15++ = " << f15++ << " (è¿”å›æ—§å€¼)" << endl;
    cout << "æ‰§è¡Œå f15 = " << f15 << endl;

    cout << "\n---- æµ‹è¯• cout << f (å·²åœ¨ä¸Šé¢ä½¿ç”¨) ----\n";
    cout << "é“¾å¼è¾“å‡ºæµ‹è¯•: " << f8 << " + " << f9 << " = " << f10 << endl;

    // Ex21 =================================
    cout << "\n==== E21 - æµ‹è¯•å¼‚å¸¸å¤„ç† ====\n";

    cout << "\n---- æ„é€ å‡½æ•°ä¸­åˆ†æ¯ä¸º0 ----\n";
    try
    {
        Fraction f16(1, 0);
        cout << "f16 = " << f16 << endl; // ä¸ä¼šæ‰§è¡Œ
    }
    catch (const FractionException &e)
    {
        cout << "æ•è·åˆ° FractionException å¼‚å¸¸: " << e.getInfo() << endl;
        cout << "  é”™è¯¯çš„åˆ†æ•°å€¼: " << e.getNumerateur() << "/" << e.getDenominateur() << endl;
    }

    cout << "\n---- setFraction ä¸­åˆ†æ¯ä¸º0 ----\n";
    try
    {
        Fraction f17(3, 4);
        cout << "åˆ›å»º f17 = " << f17 << endl;
        cout << "å°è¯•å°† f17 è®¾ç½®ä¸º 5/0..." << endl;
        f17.setFraction(5, 0);
        cout << "f17 = " << f17 << endl;
    }
    catch (const FractionException &e)
    {
        cout << "æ•è·åˆ° FractionException å¼‚å¸¸: " << e.getInfo() << endl;
        cout << "  é”™è¯¯çš„åˆ†æ•°å€¼: " << e.getNumerateur() << "/" << e.getDenominateur() << endl;
    }

    cout << "\n---- æ­£å¸¸çš„åˆ†æ•°è¿ç®— ----\n";
    try
    {
        Fraction f18(1, 2);
        Fraction f19(1, 3);
        Fraction f20 = f18 + f19;
        cout << f18 << " + " << f19 << " = " << f20 << " âœ“" << endl;
    }
    catch (const FractionException &e)
    {
        cout << "æ•è·åˆ° FractionException å¼‚å¸¸: " << e.getInfo() << endl;
    }

    cout << "\n---- ç¨‹åºç»“æŸ ----\n";

    return 0;
}

/*
Ex19ç»“æœï¼š

+ æ„é€  Fraction å¯¹è±¡: 0x16b5e2fb4 => 3/4
+ æ„é€  Fraction å¯¹è±¡: 0x16b5e2fac => 1/6
+ æ„é€  Fraction å¯¹è±¡: 0x120606140 => 1/2

---- è¿›å…¥ä¸€ä¸ªä½œç”¨åŸŸ ----
+ æ„é€  Fraction å¯¹è±¡: 0x16b5e2f80 => 3/8
+ æ„é€  Fraction å¯¹è±¡: 0x16b5e2f78 => 4/6
+ æ„é€  Fraction å¯¹è±¡: 0x120605fd0 => 1/3
- ææ„ Fraction å¯¹è±¡: 0x16b5e2f78 => 2/3ï¼ˆp5åŒ–ç®€åçš„ç»“æœï¼‰
- ææ„ Fraction å¯¹è±¡: 0x16b5e2f80 => 3/8
---- ç¦»å¼€ä½œç”¨åŸŸ ----

---- è¿›å…¥å‡½æ•° ----
+ æ„é€  Fraction å¯¹è±¡: 0x16b5e2eb8 => 7/8
+ æ„é€  Fraction å¯¹è±¡: 0x120605fe0 => 2/3
- ææ„ Fraction å¯¹è±¡: 0x16b5e2eb8 => 7/8
---- ç¦»å¼€å‡½æ•° ----

---- æ‰‹åŠ¨é‡Šæ”¾å†…å­˜ ----
- ææ„ Fraction å¯¹è±¡: 0x120605fd0 => 1/3
- ææ„ Fraction å¯¹è±¡: 0x120605fe0 => 2/3
- ææ„ Fraction å¯¹è±¡: 0x120606140 => 1/2

---- æµ‹è¯•åŠ æ³• ----
3/4 + 1/6
+ æ„é€  Fraction å¯¹è±¡: 0x16b5e2f68 => 22/24
11/12

---- ç¨‹åºç»“æŸ ----
- ææ„ Fraction å¯¹è±¡: 0x16b5e2f68 => 11/12
- ææ„ Fraction å¯¹è±¡: 0x16b5e2fac => 1/6
- ææ„ Fraction å¯¹è±¡: 0x16b5e2fb4 => 3/4
*/

/*
Ex20ç»“æœï¼š

==== E20 - æµ‹è¯•è¿ç®—ç¬¦é‡è½½ ====

---- æµ‹è¯• f1 + f2 (Fraction + Fraction) ----
+ æ„é€  Fraction å¯¹è±¡: 0x16d45ef60 => 1/2
+ æ„é€  Fraction å¯¹è±¡: 0x16d45ef58 => 1/3
f8 = 1/2, f9 = 1/3
+ æ„é€  Fraction å¯¹è±¡: 0x16d45ef50 => 5/6
f8 + f9 = 5/6

---- æµ‹è¯• Fraction + int å’Œ int + Fraction ----
+ æ„é€  Fraction å¯¹è±¡: 0x16d45ef48 => 2/3
f11 = 2/3
+ æ„é€  Fraction å¯¹è±¡: 0x16d45ef40 => 8/3
f11 + 2 = 8/3
+ æ„é€  Fraction å¯¹è±¡: 0x16d45ef38 => 11/3
3 + f11 = 11/3

---- æµ‹è¯• ++f å’Œ f++ ----
+ æ„é€  Fraction å¯¹è±¡: 0x16d45ef30 => 3/4
åŸå§‹å€¼ f14 = 3/4
å‰ç¼€ ++f14 = 7/4
æ‰§è¡Œå f14 = 7/4
+ æ„é€  Fraction å¯¹è±¡: 0x16d45ef28 => 5/6

åŸå§‹å€¼ f15 = 5/6
åç¼€ f15++ = + æ‹·è´æ„é€  Fraction: 0x16d45ef20 <= 0x16d45ef28
5/6 (è¿”å›æ—§å€¼)
- ææ„ Fraction å¯¹è±¡: 0x16d45ef20 => 5/6
æ‰§è¡Œå f15 = 11/6

---- æµ‹è¯• cout << f (å·²åœ¨ä¸Šé¢ä½¿ç”¨) ----
é“¾å¼è¾“å‡ºæµ‹è¯•: 1/2 + 1/3 = 5/6
*/

/*
Ex21ç»“æœ

==== E21 - æµ‹è¯•å¼‚å¸¸å¤„ç† ====

---- æ„é€ å‡½æ•°ä¸­åˆ†æ¯ä¸º0 ----
+ æ„é€  Fraction å¯¹è±¡: 0x16f606f18 => 1/0
æ•è·åˆ° FractionException å¼‚å¸¸: é”™è¯¯ï¼šåˆ†æ¯ä¸èƒ½ä¸º0ï¼
  é”™è¯¯çš„åˆ†æ•°å€¼: 1/0

---- setFraction ä¸­åˆ†æ¯ä¸º0 ----
+ æ„é€  Fraction å¯¹è±¡: 0x16f606f08 => 3/4
åˆ›å»º f17 = 3/4
å°è¯•å°† f17 è®¾ç½®ä¸º 5/0...
- ææ„ Fraction å¯¹è±¡: 0x16f606f08 => 5/0
æ•è·åˆ° FractionException å¼‚å¸¸: é”™è¯¯ï¼šåˆ†æ¯ä¸èƒ½ä¸º0ï¼
  é”™è¯¯çš„åˆ†æ•°å€¼: 5/0

---- æ­£å¸¸çš„åˆ†æ•°è¿ç®— ----
+ æ„é€  Fraction å¯¹è±¡: 0x16f606ef8 => 1/2
+ æ„é€  Fraction å¯¹è±¡: 0x16f606ef0 => 1/3
+ æ„é€  Fraction å¯¹è±¡: 0x16f606ee8 => 5/6
1/2 + 1/3 = 5/6 âœ“
- ææ„ Fraction å¯¹è±¡: 0x16f606ee8 => 5/6
- ææ„ Fraction å¯¹è±¡: 0x16f606ef0 => 1/3
- ææ„ Fraction å¯¹è±¡: 0x16f606ef8 => 1/2
*/
```


# Ex20
```cpp
/*
è¯·çœ‹ Ex19&20 æ–‡ä»¶å¤¹çš„ Patch è¡¥ä¸
*/
```


# Ex21
```cpp
/*
çŸ¥è¯†ç‚¹ï¼šé”™è¯¯ç±»ä¸ªæ€§åŒ–

è¯¦ç»†çœ‹Ex19&20&21/fractionException.hpp ä»¥åŠ Ex19&20&21/fraction.cpp ä¸­çš„ç®€åŒ–å‡½æ•°
*/
```


# Ex22
```cpp
/*
è¦å®ç°ä¸€ä¸ªSETæ¸¸æˆï¼Œä¸»è¦å†…å®¹å°±æ˜¯å¯¹å¡ç‰Œæ•°æ®è¿›è¡Œç®¡ç†
ç›´æ¥åœ¨è€å¸ˆçš„ä»£ç ä¸Šåšäº†é…ç½®ä¼˜åŒ–ã€æ³¨é‡Šç­‰ï¼ˆè¯¦æƒ…è¯·çœ‹ Ex22 æ–‡ä»¶å¤¹ï¼‰

ä¸‹é¢æ˜¯ä¸€äº›æ¦‚å¿µï¼š
- å…³è”å…³ç³»ï¼š
    - å•å‘å…³è”ï¼šæ¯”å¦‚ AçŸ¥é“ï¼Œä½†æ˜¯Bä¸çŸ¥é“ ï¼Œé‚£ä¹ˆå°±åœ¨ A çš„publicä¸­å£°æ˜ B* ptr_to_b
    - åŒå‘å…³è”ï¼šé€šè¿‡ vectoræˆ–å…¶ä»–å®¹å™¨æ¥å®ç°å¤šå¯¹å¤š std::vector<å¯¹æ–¹*>
- ç»„åˆå…³ç³»ï¼šä¸¤ä¸ªç±»æ¯”å¦‚ Aæ‹¥æœ‰B æ—¶ï¼Œé‚£ä¹ˆ A å…¨æƒå¯¹ B çš„å®ä¾‹è¿›è¡Œç”Ÿå‘½å‘¨æœŸç®¡ç†ï¼ˆä¾‹å¦‚æœ¬é¢˜ä¸­çš„ Jeu å’Œ Carteï¼‰
- èšåˆå…³ç³»ï¼šAç±»å¯¹è±¡ä¸­åŒ…å«Bç±»å¯¹è±¡çš„å¼•ç”¨æˆ–è€…æŒ‡é’ˆï¼Œä½†æ˜¯ Aä¸ç®¡ç†Bçš„ç”Ÿå‘½å‘¨æœŸ ï¼Œæ˜¯ä¸€ç§å¼±æ‹¥æœ‰çš„å…³ç³»ï¼ŒåŒ…å«å¯¹è±¡Aé”€æ¯äº†ä¸å½±å“èšåˆå¯¹è±¡Bï¼ˆä¾‹å¦‚æœ¬é¢˜ä¸­çš„ Carte å’Œ Piocheï¼‰
*/
```


# Ex22&23 æ–‡ä»¶å¤¹
## config.hpp
```h
#ifndef SET_CONFIG_H
#define SET_CONFIG_H

#include <cstddef> // å¼•å…¥ size_t ç±»å‹å®šä¹‰

/**
 * ============================================================================
 * é…ç½®æ–‡ä»¶è¯´æ˜ (Configuration File Documentation)
 * ============================================================================
 *
 * è®¾è®¡ç†å¿µï¼š
 * ä¹‹å‰çš„ä»£ç æ˜¯ç›´æ¥åœ¨ç±»ä¸­ä½¿ç”¨é­”æ³•æ•°å­—ï¼ˆå¦‚ 81ã€3 ç­‰ï¼‰æ¥è¡¨ç¤ºå¡ç‰Œæ•°é‡å’Œé…ç½®ã€‚
 * è¿™ç§æ–¹å¼è™½ç„¶ç›´è§‚ï¼Œä½†å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š
 * 1. å¯ç»´æŠ¤æ€§å·®ï¼šä¿®æ”¹é…ç½®éœ€è¦åœ¨å¤šå¤„æŸ¥æ‰¾å’Œæ›¿æ¢
 * 2. æ˜“å‡ºé”™ï¼šä¸åŒåœ°æ–¹çš„æ•°å­—å¯èƒ½ä¸ä¸€è‡´
 * 3. å¯è¯»æ€§å·®ï¼šæ•°å­—æœ¬èº«æ— æ³•è¡¨è¾¾å…¶å«ä¹‰
 *
 * æ”¹è¿›æ–¹æ¡ˆï¼š
 * ä½¿ç”¨é…ç½®æ–‡ä»¶ç»Ÿä¸€ç®¡ç†æ‰€æœ‰å¸¸é‡ï¼Œéµå¾ª"å•ä¸€æ•°æ®æº"åŸåˆ™ã€‚
 * ä¼˜åŠ¿ï¼š
 * - é›†ä¸­ç®¡ç†ï¼šæ‰€æœ‰é…ç½®åœ¨ä¸€ä¸ªåœ°æ–¹å®šä¹‰
 * - ç±»å‹å®‰å…¨ï¼šä½¿ç”¨ constexpr åœ¨ç¼–è¯‘æœŸç¡®å®šå€¼
 * - æ˜“äºæ‰©å±•ï¼šæ·»åŠ æ–°é…ç½®æ— éœ€ä¿®æ”¹æ ¸å¿ƒä»£ç 
 * - è¯­ä¹‰æ¸…æ™°ï¼šå¸¸é‡åç§°è¡¨è¾¾äº†å…¶ç”¨é€”
 *
 * æ•°å­¦åŸºç¡€ï¼š
 * SET æ¸¸æˆçš„å¡ç‰Œæ€»æ•° = 3^4 = 81
 * ï¼ˆ4 ä¸ªç‰¹å¾ï¼Œæ¯ä¸ªç‰¹å¾æœ‰ 3 ç§å¯èƒ½ï¼‰
 */

namespace config
{
    // ========================================================================
    // æ¸¸æˆæ ¸å¿ƒé…ç½® (Game Core Configuration)
    // ========================================================================

    /**
     * NB_CARTES: æ¸¸æˆä¸­å¡ç‰Œçš„æ€»æ•°
     * è®¡ç®—å…¬å¼: NB_COULEURS Ã— NB_NOMBRES Ã— NB_FORMES Ã— NB_REMPLISSAGES
     *          = 3 Ã— 3 Ã— 3 Ã— 3 = 81
     * è¿™æ˜¯ SET æ¸¸æˆçš„å›ºå®šè§„åˆ™ï¼Œæ¯å¼ å¡ç‰Œéƒ½æ˜¯å”¯ä¸€çš„
     */
    constexpr size_t NB_CARTES = 81;

    /**
     * NB_COULEURS: å¡ç‰Œé¢œè‰²çš„ç§ç±»æ•°
     * å¯é€‰å€¼ï¼šrouge (çº¢), mauve (ç´«), vert (ç»¿)
     */
    constexpr size_t NB_COULEURS = 3;

    /**
     * NB_NOMBRES: å¡ç‰Œä¸Šç¬¦å·çš„æ•°é‡ç§ç±»
     * å¯é€‰å€¼ï¼š1, 2, 3
     */
    constexpr size_t NB_NOMBRES = 3;

    /**
     * NB_FORMES: å¡ç‰Œç¬¦å·çš„å½¢çŠ¶ç§ç±»æ•°
     * å¯é€‰å€¼ï¼šovale (æ¤­åœ†), vague (æ³¢æµª), losange (è±å½¢)
     */
    constexpr size_t NB_FORMES = 3;

    /**
     * NB_REMPLISSAGES: å¡ç‰Œç¬¦å·çš„å¡«å……æ–¹å¼ç§ç±»æ•°
     * å¯é€‰å€¼ï¼šplein (å®å¿ƒ), vide (ç©ºå¿ƒ), hachure (é˜´å½±)
     */
    constexpr size_t NB_REMPLISSAGES = 3;

    // ========================================================================
    // æ¸¸æˆè§„åˆ™é…ç½® (Game Rules Configuration)
    // ========================================================================

    /**
     * PLATEAU_MIN_CARTES: æ¸¸æˆæ¡Œé¢ä¸Šæœ€å°‘åº”ä¿æŒçš„å¡ç‰Œæ•°
     * æ ¹æ® SET æ¸¸æˆè§„åˆ™ï¼Œæ­£å¸¸æƒ…å†µä¸‹æ¡Œé¢åº”æœ‰ 12 å¼ å¡ç‰Œ
     */
    constexpr size_t PLATEAU_MIN_CARTES = 12;

    /**
     * PLATEAU_INITIAL_CAPACITY: Plateau åŠ¨æ€æ•°ç»„çš„åˆå§‹å®¹é‡
     * é¿å…é¢‘ç¹æ‰©å®¹ï¼Œæé«˜æ€§èƒ½
     */
    constexpr size_t PLATEAU_INITIAL_CAPACITY = 5;

    /**
     * PLATEAU_INCREMENT: Plateau æ‰©å®¹æ—¶æ¯æ¬¡å¢åŠ çš„å®¹é‡
     * å½“æ•°ç»„æ»¡æ—¶ï¼Œä»¥æ­¤å€¼ä¸ºå¢é‡è¿›è¡Œæ‰©å®¹
     */
    constexpr size_t PLATEAU_INCREMENT = 5;

    // ========================================================================
    // æ˜¾ç¤ºé…ç½® (Display Configuration)
    // ========================================================================

    /**
     * PLATEAU_CARTES_PER_LINE: æ‰“å° Plateau æ—¶æ¯è¡Œæ˜¾ç¤ºçš„å¡ç‰Œæ•°
     * ç”¨äºæ ¼å¼åŒ–è¾“å‡ºï¼Œè®©æ˜¾ç¤ºæ›´æ•´é½
     */
    constexpr size_t PLATEAU_CARTES_PER_LINE = 3;
}

#endif // SET_CONFIG_H
```

## set.h
```h
#ifndef _SET_H
#define _SET_H

#include "config.hpp"
#include <iostream>
#include <string>
#include <initializer_list>
#include <array>
#include <cstdlib>

using namespace std;

/**
 * ============================================================================
 * SET æ¸¸æˆå‘½åç©ºé—´ (SET Game Namespace)
 * ============================================================================
 *
 * æœ¬æ–‡ä»¶å®ç°äº† SET çº¸ç‰Œæ¸¸æˆçš„æ ¸å¿ƒæ•°æ®ç»“æ„å’Œç±»ã€‚
 * SET æ˜¯ä¸€æ¬¾è§‚å¯ŸåŠ›æ¸¸æˆï¼Œç©å®¶éœ€è¦ä»æ¡Œé¢ä¸Šçš„å¡ç‰Œä¸­æ‰¾å‡ºæ»¡è¶³ç‰¹å®šè§„åˆ™çš„ä¸‰å¼ å¡ç»„åˆã€‚
 *
 * ä¸»è¦ç±»çš„å…³ç³»ï¼š
 * - Carte: è¡¨ç¤ºå•å¼ å¡ç‰Œï¼ˆç»„åˆå…³ç³» - ç”± Jeu åˆ›å»ºå’Œæ‹¥æœ‰ï¼‰
 * - Jeu: å•ä¾‹æ¨¡å¼ï¼Œç®¡ç†æ‰€æœ‰ 81 å¼ å¡ç‰Œï¼ˆç»„åˆå…³ç³» - æ‹¥æœ‰æ‰€æœ‰ Carteï¼‰
 * - Pioche: ç‰Œå †ï¼Œç®¡ç†å¾…å‘çš„å¡ç‰Œï¼ˆèšåˆå…³ç³» - æŒ‡å‘ Carteï¼Œä¸æ‹¥æœ‰ï¼‰
 * - Plateau: æ¡Œé¢ï¼Œæ˜¾ç¤ºå½“å‰å¯è§çš„å¡ç‰Œï¼ˆèšåˆå…³ç³» - æŒ‡å‘ Carteï¼Œä¸æ‹¥æœ‰ï¼‰
 * - Combinaison: ä¸‰å¼ å¡çš„ç»„åˆï¼ˆèšåˆå…³ç³» - æŒ‡å‘ Carteï¼Œä¸æ‹¥æœ‰ï¼‰
 * - Controleur: æ¸¸æˆæ§åˆ¶å™¨ï¼ˆç»„åˆå…³ç³» - æ‹¥æœ‰ Jeuã€Piocheã€Plateauï¼‰
 */
namespace Set
{
	// ========================================================================
	// å¼‚å¸¸å¤„ç†ç±» (Exception Handling)
	// ========================================================================

	/**
	 * SetException: SET æ¸¸æˆä¸­çš„å¼‚å¸¸ç±»
	 *
	 * è®¾è®¡è¯´æ˜ï¼š
	 * - ç”¨äºå¤„ç†æ¸¸æˆä¸­çš„å„ç§å¼‚å¸¸æƒ…å†µï¼ˆå¦‚ç‰Œå †ä¸ºç©ºã€ç´¢å¼•è¶Šç•Œç­‰ï¼‰
	 * - å­˜å‚¨é”™è¯¯ä¿¡æ¯å­—ç¬¦ä¸²ï¼Œä¾¿äºè°ƒè¯•å’Œé”™è¯¯æç¤º
	 *
	 * ä½¿ç”¨åœºæ™¯ï¼š
	 * - è®¿é—®ä¸å­˜åœ¨çš„å¡ç‰Œç´¢å¼•
	 * - ä»ç©ºç‰Œå †ä¸­æŠ½ç‰Œ
	 * - è¿­ä»£å™¨è¶Šç•Œ
	 */
	class SetException
	{
	public:
		// æ„é€ å‡½æ•°ï¼šæ¥æ”¶é”™è¯¯ä¿¡æ¯
		SetException(const string &i) : info(i) {}

		// è·å–é”™è¯¯ä¿¡æ¯
		string getInfo() const { return info; }

	private:
		string info; // å­˜å‚¨é”™è¯¯æè¿°ä¿¡æ¯
	};

	// ========================================================================
	// å¡ç‰Œç‰¹å¾æšä¸¾ (Card Characteristics Enumerations)
	// ========================================================================

	/**
	 * è®¾è®¡ç†å¿µï¼šä½¿ç”¨å¼ºç±»å‹æšä¸¾ï¼ˆenum classï¼‰
	 *
	 * ä¸ºä»€ä¹ˆä½¿ç”¨ enum class è€Œä¸æ˜¯æ™®é€š enumï¼Ÿ
	 * 1. ç±»å‹å®‰å…¨ï¼šä¸ä¼šéšå¼è½¬æ¢ä¸ºæ•´æ•°ï¼Œé¿å…è¯¯ç”¨
	 * 2. ä½œç”¨åŸŸé™å®šï¼šæšä¸¾å€¼åœ¨æšä¸¾ç±»å‹å†…éƒ¨ï¼Œé¿å…å‘½åå†²çª
	 * 3. å‰å‘å£°æ˜ï¼šå¯ä»¥å‰å‘å£°æ˜ï¼Œæé«˜ç¼–è¯‘æ•ˆç‡
	 *
	 * ä¾‹å¦‚ï¼šCouleur::rouge è€Œä¸æ˜¯ rougeï¼ˆé¿å…ä¸å…¶ä»–åœ°æ–¹çš„ rouge å†²çªï¼‰
	 */

	/**
	 * Couleur: å¡ç‰Œç¬¦å·çš„é¢œè‰²
	 * - rouge: çº¢è‰²
	 * - mauve: ç´«è‰²ï¼ˆæˆ–ç§°ç´«çº¢è‰²ï¼‰
	 * - vert: ç»¿è‰²
	 */
	enum class Couleur
	{
		rouge, // çº¢è‰²
		mauve, // ç´«è‰²
		vert   // ç»¿è‰²
	};

	/**
	 * Nombre: å¡ç‰Œä¸Šç¬¦å·çš„æ•°é‡
	 * - un: 1 ä¸ªç¬¦å·
	 * - deux: 2 ä¸ªç¬¦å·
	 * - trois: 3 ä¸ªç¬¦å·
	 *
	 * æ³¨æ„ï¼šæ˜¾å¼æŒ‡å®šå€¼ä¾¿äºåç»­é€»è¾‘åˆ¤æ–­å’Œè¾“å‡º
	 */
	enum class Nombre
	{
		un = 1,	  // 1 ä¸ª
		deux = 2, // 2 ä¸ª
		trois = 3 // 3 ä¸ª
	};

	/**
	 * Forme: å¡ç‰Œç¬¦å·çš„å½¢çŠ¶
	 * - ovale: æ¤­åœ†å½¢
	 * - vague: æ³¢æµªå½¢
	 * - losange: è±å½¢
	 */
	enum class Forme
	{
		ovale,	// æ¤­åœ†å½¢
		vague,	// æ³¢æµªå½¢
		losange // è±å½¢
	};

	/**
	 * Remplissage: å¡ç‰Œç¬¦å·çš„å¡«å……æ–¹å¼
	 * - plein: å®å¿ƒå¡«å……
	 * - vide: ç©ºå¿ƒï¼ˆåªæœ‰è½®å»“ï¼‰
	 * - hachure: é˜´å½±å¡«å……ï¼ˆæ–œçº¿çº¹ç†ï¼‰
	 */
	enum class Remplissage
	{
		plein,	// å®å¿ƒ
		vide,	// ç©ºå¿ƒ
		hachure // é˜´å½±
	};

	// ========================================================================
	// æšä¸¾è½¬æ¢ä¸è¾“å‡ºå‡½æ•° (Enum Conversion and Output Functions)
	// ========================================================================

	/**
	 * toString ç³»åˆ—å‡½æ•°ï¼šå°†æšä¸¾å€¼è½¬æ¢ä¸ºå­—ç¬¦ä¸²è¡¨ç¤º
	 * ç”¨é€”ï¼šä¾¿äºè°ƒè¯•å’Œæ˜¾ç¤ºå¡ç‰Œä¿¡æ¯
	 */
	string toString(Couleur c);
	string toString(Nombre v);
	string toString(Forme f);
	string toString(Remplissage v);

	/**
	 * operator<< é‡è½½ï¼šæ”¯æŒç›´æ¥è¾“å‡ºæšä¸¾å€¼åˆ°æµ
	 * ä½¿ç”¨æ–¹å¼ï¼šcout << Couleur::rouge << endl;
	 */
	ostream &operator<<(ostream &f, Couleur c);
	ostream &operator<<(ostream &f, Nombre v);
	ostream &operator<<(ostream &f, Forme x);
	ostream &operator<<(ostream &f, Remplissage r);

	// ========================================================================
	// æšä¸¾å€¼åˆ—è¡¨ (Enum Value Lists)
	// ========================================================================

	/**
	 * å…¨å±€å¸¸é‡åˆ—è¡¨ï¼šåŒ…å«æ¯ä¸ªç‰¹å¾çš„æ‰€æœ‰å¯èƒ½å€¼
	 *
	 * è®¾è®¡è¯´æ˜ï¼š
	 * - ä½¿ç”¨ initializer_list å…è®¸åœ¨å¾ªç¯ä¸­éå†æ‰€æœ‰å¯èƒ½çš„å€¼
	 * - extern å£°æ˜è¡¨ç¤ºåœ¨ set.cpp ä¸­å®šä¹‰
	 *
	 * ç”¨é€”ï¼š
	 * 1. ç”Ÿæˆæ‰€æœ‰ 81 å¼ å¡ç‰Œï¼ˆ4 å±‚åµŒå¥—å¾ªç¯ï¼‰
	 * 2. æ˜¾ç¤ºæ‰€æœ‰å¯èƒ½çš„ç‰¹å¾å€¼
	 * 3. éªŒè¯å’Œæµ‹è¯•
	 */
	extern std::initializer_list<Couleur> Couleurs;
	extern std::initializer_list<Nombre> Nombres;
	extern std::initializer_list<Forme> Formes;
	extern std::initializer_list<Remplissage> Remplissages;

	/**
	 * print ç³»åˆ—å‡½æ•°ï¼šæ‰“å°æ‰€æœ‰å¯èƒ½çš„ç‰¹å¾å€¼
	 * å‚æ•° f: è¾“å‡ºæµï¼Œé»˜è®¤ä¸ºæ ‡å‡†è¾“å‡º cout
	 */
	void printCouleurs(std::ostream &f = cout);
	void printNombres(std::ostream &f = cout);
	void printFormes(std::ostream &f = cout);
	void printRemplissages(std::ostream &f = cout);

	// ========================================================================
	// Carte ç±»ï¼šè¡¨ç¤ºå•å¼ å¡ç‰Œ (Card Class)
	// ========================================================================

	/**
	 * Carte: ä»£è¡¨æ¸¸æˆä¸­çš„ä¸€å¼ å¡ç‰Œ
	 *
	 * è®¾è®¡è¦ç‚¹ï¼ˆå›ç­”é¢˜ç›®é—®é¢˜1ï¼‰ï¼š
	 *
	 * 1. ä¸ºä»€ä¹ˆæ„é€ å‡½æ•°æ˜¯ç§æœ‰çš„ï¼Ÿ
	 *    - å°è£…æ€§ï¼šåªæœ‰ Jeu ç±»èƒ½åˆ›å»ºå¡ç‰Œï¼Œå¤–éƒ¨æ— æ³•éšæ„åˆ›å»º
	 *    - å•ä¸€èŒè´£ï¼šå¡ç‰Œçš„ç”Ÿå‘½å‘¨æœŸç”± Jeu ç»Ÿä¸€ç®¡ç†
	 *    - é¿å…é‡å¤ï¼šç¡®ä¿æ¯å¼ å¡ç‰Œå”¯ä¸€ï¼Œä¸ä¼šæœ‰é‡å¤åˆ›å»º
	 *
	 * 2. ä¸ºä»€ä¹ˆä½¿ç”¨ = defaultï¼Ÿ
	 *    - Carte åªåŒ…å«åŸºæœ¬ç±»å‹æˆå‘˜ï¼ˆ4ä¸ªæšä¸¾å€¼ï¼‰
	 *    - æ²¡æœ‰åŠ¨æ€åˆ†é…çš„èµ„æºï¼ˆæŒ‡é’ˆã€æ•°ç»„ç­‰ï¼‰
	 *    - ç¼–è¯‘å™¨ç”Ÿæˆçš„é»˜è®¤ç‰ˆæœ¬å·²ç»è¶³å¤Ÿï¼ˆæµ…æ‹·è´å³å¯ï¼‰
	 *    - = default æ˜ç¡®è¡¨è¾¾è®¾è®¡æ„å›¾ï¼Œæé«˜ä»£ç å¯è¯»æ€§
	 *
	 * 3. ä½•æ—¶éœ€è¦è‡ªå®šä¹‰è¿™äº›å‡½æ•°ï¼Ÿ
	 *    - å½“ç±»åŒ…å«æŒ‡é’ˆæˆå‘˜æ—¶ï¼ˆéœ€è¦æ·±æ‹·è´ï¼‰
	 *    - å½“ç±»ç®¡ç†å¤–éƒ¨èµ„æºæ—¶ï¼ˆæ–‡ä»¶ã€å†…å­˜ç­‰ï¼‰
	 *    - éµå¾ª"ä¸‰äº”æ³•åˆ™"ï¼šå¦‚æœéœ€è¦è‡ªå®šä¹‰ææ„å‡½æ•°ï¼Œ
	 *      é€šå¸¸ä¹Ÿéœ€è¦è‡ªå®šä¹‰æ‹·è´æ„é€ å‡½æ•°å’Œèµ‹å€¼è¿ç®—ç¬¦
	 *
	 * ç±»é—´å…³ç³»ï¼š
	 * - Carte ä¸ Jeuï¼šç»„åˆå…³ç³»ï¼ˆCompositionï¼‰
	 *   Jeu åˆ›å»ºå¹¶æ‹¥æœ‰æ‰€æœ‰ Carte å¯¹è±¡ï¼Œè´Ÿè´£å…¶ç”Ÿå‘½å‘¨æœŸ
	 */
	class Carte
	{
	private:
		// ====================================================================
		// ç§æœ‰æˆå‘˜å˜é‡ (Private Member Variables)
		// ====================================================================

		Couleur couleur;		 // å¡ç‰Œç¬¦å·çš„é¢œè‰²
		Nombre nombre;			 // å¡ç‰Œä¸Šç¬¦å·çš„æ•°é‡
		Forme forme;			 // å¡ç‰Œç¬¦å·çš„å½¢çŠ¶
		Remplissage remplissage; // å¡ç‰Œç¬¦å·çš„å¡«å……æ–¹å¼

		// ====================================================================
		// ç§æœ‰æ„é€ å‡½æ•° (Private Constructor)
		// ====================================================================

		/**
		 * æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–å¡ç‰Œçš„å››ä¸ªç‰¹å¾
		 *
		 * ä¸ºä»€ä¹ˆç§æœ‰ï¼Ÿ
		 * - åªå…è®¸ Jeu ç±»åˆ›å»ºå¡ç‰Œå®ä¾‹
		 * - é˜²æ­¢å¤–éƒ¨ä»£ç éšæ„åˆ›å»ºå¡ç‰Œ
		 * - ç¡®ä¿æ‰€æœ‰å¡ç‰Œéƒ½ç”± Jeu ç»Ÿä¸€ç®¡ç†
		 *
		 * ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨çš„å¥½å¤„ï¼š
		 * - ç›´æ¥åˆå§‹åŒ–æˆå‘˜ï¼Œæ•ˆç‡é«˜äºèµ‹å€¼
		 * - å¯¹äº const æˆå‘˜å’Œå¼•ç”¨æˆå‘˜ï¼Œå¿…é¡»ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨
		 */
		Carte(Couleur c, Nombre n, Forme f, Remplissage r)
			: couleur(c), nombre(n), forme(f), remplissage(r) {}

		// ====================================================================
		// ç‰¹æ®Šæˆå‘˜å‡½æ•° (Special Member Functions)
		// ====================================================================

		/**
		 * æ‹·è´æ„é€ å‡½æ•°ï¼šä½¿ç”¨é»˜è®¤å®ç°
		 *
		 * ä¸ºä»€ä¹ˆ = default è¶³å¤Ÿï¼Ÿ
		 * - Carte çš„æ‰€æœ‰æˆå‘˜éƒ½æ˜¯æšä¸¾ç±»å‹ï¼ˆå€¼ç±»å‹ï¼‰
		 * - æ²¡æœ‰æŒ‡é’ˆæˆ–åŠ¨æ€åˆ†é…çš„å†…å­˜
		 * - ç¼–è¯‘å™¨ç”Ÿæˆçš„æˆå‘˜é€ä¸ªæ‹·è´å·²ç»æ»¡è¶³éœ€æ±‚
		 */
		Carte(const Carte &) = default;

		/**
		 * èµ‹å€¼è¿ç®—ç¬¦ï¼šä½¿ç”¨é»˜è®¤å®ç°
		 *
		 * é»˜è®¤è¡Œä¸ºï¼šé€æˆå‘˜èµ‹å€¼
		 * å¯¹äº Carte æ¥è¯´å·²ç»è¶³å¤Ÿ
		 */
		Carte &operator=(const Carte &) = default;

		/**
		 * ææ„å‡½æ•°ï¼šä½¿ç”¨é»˜è®¤å®ç°
		 *
		 * ä¸ºä»€ä¹ˆä¸éœ€è¦è‡ªå®šä¹‰ï¼Ÿ
		 * - Carte æ²¡æœ‰ç®¡ç†ä»»ä½•éœ€è¦æ‰‹åŠ¨é‡Šæ”¾çš„èµ„æº
		 * - æ²¡æœ‰åŠ¨æ€åˆ†é…çš„å†…å­˜
		 * - æ²¡æœ‰æ‰“å¼€çš„æ–‡ä»¶æˆ–ç½‘ç»œè¿æ¥
		 * - æšä¸¾ç±»å‹çš„é”€æ¯ç”±ç¼–è¯‘å™¨è‡ªåŠ¨å¤„ç†
		 */
		~Carte() = default;

		// ====================================================================
		// å‹å…ƒå£°æ˜ (Friend Declaration)
		// ====================================================================

		/**
		 * å‹å…ƒç±»ï¼šå…è®¸ Jeu è®¿é—® Carte çš„ç§æœ‰æˆå‘˜
		 *
		 * ä¸ºä»€ä¹ˆéœ€è¦ï¼Ÿ
		 * - Jeu éœ€è¦è°ƒç”¨ Carte çš„ç§æœ‰æ„é€ å‡½æ•°æ¥åˆ›å»ºå¡ç‰Œ
		 * - ä½“ç°äº† Carte ä¸ Jeu ä¹‹é—´çš„ç´§å¯†ç»„åˆå…³ç³»
		 * - Jeu è´Ÿè´£ Carte çš„æ•´ä¸ªç”Ÿå‘½å‘¨æœŸ
		 */
		friend class Jeu;

	public:
		// ====================================================================
		// å…¬æœ‰è®¿é—®å™¨æ–¹æ³• (Public Accessor Methods)
		// ====================================================================

		/**
		 * Getter æ–¹æ³•ï¼šè·å–å¡ç‰Œçš„å„ä¸ªç‰¹å¾
		 *
		 * è®¾è®¡è¯´æ˜ï¼š
		 * - const æˆå‘˜å‡½æ•°ï¼šä¸ä¿®æ”¹å¯¹è±¡çŠ¶æ€
		 * - è¿”å›å€¼ç±»å‹ï¼šç›´æ¥è¿”å›æšä¸¾å€¼ï¼ˆå€¼ç±»å‹ï¼Œå¼€é”€å°ï¼‰
		 * - å‘½åè§„èŒƒï¼šéµå¾ª getCamelCase é£æ ¼
		 */
		Couleur getCouleur() const { return couleur; }
		Nombre getNombre() const { return nombre; }
		Forme getForme() const { return forme; }
		Remplissage getRemplissage() const { return remplissage; }
	};

	/**
	 * è¾“å‡ºè¿ç®—ç¬¦é‡è½½ï¼šæ”¯æŒç›´æ¥è¾“å‡º Carte å¯¹è±¡
	 * æ ¼å¼ï¼š[é¢œè‰²å½¢çŠ¶æ•°é‡å¡«å……]ï¼Œä¾‹å¦‚ [RO2P] è¡¨ç¤ºçº¢è‰²æ¤­åœ†2ä¸ªå®å¿ƒ
	 */
	ostream &operator<<(ostream &f, const Carte &c);

	// ========================================================================
	// Jeu ç±»ï¼šç®¡ç†æ‰€æœ‰å¡ç‰Œçš„å•ä¾‹ç±» (Game Singleton Class)
	// ========================================================================

	/**
	 * Jeu: æ¸¸æˆç±»ï¼Œç®¡ç†æ‰€æœ‰ 81 å¼ å¡ç‰Œ
	 *
	 * è®¾è®¡è¦ç‚¹ï¼ˆå›ç­”é¢˜ç›®é—®é¢˜2ã€3ã€4ã€5ï¼‰ï¼š
	 *
	 * é—®é¢˜2ï¼šå…³äºæ•°ç»„åˆå§‹åŒ–
	 * - Carte cartes[81]; å¦‚æœæ˜¯å¯¹è±¡æ•°ç»„å°±å¿…é¡»æœ‰åˆå§‹åŒ–å™¨ï¼Œå¦åˆ™ç¼–è¯‘å™¨ä¸çŸ¥é“è¯¥å¦‚ä½•åˆ›å»ºè¿™ä¸ªæ•°ç»„
	 *   ruæä¾›åˆå§‹åŒ–å™¨ï¼šCarte cartes[3] = {c1, c2, c3};
	 * - const Carte* cartes[81]; æŒ‡é’ˆæ•°ç»„å¯ä»¥ä¸åˆå§‹åŒ–
	 *   æŒ‡é’ˆæœ¬èº«å¯ä»¥ç¨åèµ‹å€¼
	 *
	 * é—®é¢˜3ï¼šCarte ä¸ Jeu çš„å…³ç³»
	 * - ç»„åˆå…³ç³»ï¼ˆCompositionï¼Œå®å¿ƒè±å½¢ï¼‰
	 * - Jeu æ‹¥æœ‰å¹¶ç®¡ç†æ‰€æœ‰ Carte å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸ
	 * - Carte ä¸èƒ½ç‹¬ç«‹äº Jeu å­˜åœ¨
	 * - UMLè¡¨ç¤ºï¼šJeu â—†â€”â€”> Carte (1å¯¹81çš„ç»„åˆ)
	 *
	 * é—®é¢˜4ï¼šä¸ºä»€ä¹ˆä½¿ç”¨ const Carte*ï¼Ÿ
	 * - å¸¸é‡æŒ‡é’ˆä¿æŠ¤ï¼šé˜²æ­¢æ„å¤–ä¿®æ”¹å¡ç‰Œå†…å®¹
	 * - å¡ç‰Œä¸€æ—¦åˆ›å»ºå°±ä¸åº”è¯¥æ”¹å˜ï¼ˆç¬¦åˆ SET æ¸¸æˆè§„åˆ™ï¼‰
	 * - ç±»å‹å®‰å…¨ï¼šç¼–è¯‘å™¨ä¼šé˜»æ­¢é€šè¿‡æŒ‡é’ˆä¿®æ”¹ Carte
	 * - å¯¹æ¯”ï¼šCarte* å…è®¸ä¿®æ”¹ï¼Œconst Carte* åªè¯»
	 *
	 * é—®é¢˜5ï¼šä¸ºä»€ä¹ˆç¦æ­¢æ‹·è´ï¼Ÿ
	 * - å•ä¾‹æ¨¡å¼ï¼šå…¨å±€åªåº”è¯¥æœ‰ä¸€ä¸ª Jeu å®ä¾‹
	 * - èµ„æºç®¡ç†ï¼šé¿å…å¤šä¸ª Jeu å¯¹è±¡ç®¡ç†åŒä¸€æ‰¹å¡ç‰Œ
	 * - é˜²æ­¢æ‚¬ç©ºæŒ‡é’ˆï¼šæ‹·è´ä¼šå¯¼è‡´æŒ‡é’ˆç®¡ç†æ··ä¹±
	 *
	 * å•ä¾‹æ¨¡å¼è¯´æ˜ï¼š
	 * - ä¿è¯å…¨å±€åªæœ‰ä¸€ä¸ª Jeu å®ä¾‹
	 * - é€šè¿‡ getInstance() è·å–å®ä¾‹
	 * - ç§æœ‰æ„é€ å‡½æ•°é˜²æ­¢å¤–éƒ¨åˆ›å»º
	 */
	class Jeu
	{
	private:
		// ====================================================================
		// ç§æœ‰æˆå‘˜å˜é‡ (Private Member Variables)
		// ====================================================================

		/**
		 * cartes: å­˜å‚¨æ‰€æœ‰ 81 å¼ å¡ç‰Œçš„æŒ‡é’ˆæ•°ç»„
		 *
		 * è®¾è®¡ç»†èŠ‚ï¼š
		 * - const Carte*ï¼šæŒ‡å‘å¸¸é‡ Carte çš„æŒ‡é’ˆï¼Œå¡ç‰Œå†…å®¹ä¸å¯ä¿®æ”¹
		 * - å›ºå®šå¤§å°æ•°ç»„ï¼š81 = 3^4ï¼ˆ4ä¸ªç‰¹å¾å„3ç§å¯èƒ½ï¼‰
		 * - ä½¿ç”¨é…ç½®å¸¸é‡ï¼šconfig::NB_CARTESï¼Œä¾¿äºç»Ÿä¸€ç®¡ç†
		 *
		 * ä¸ºä»€ä¹ˆæ˜¯æŒ‡é’ˆæ•°ç»„è€Œä¸æ˜¯å¯¹è±¡æ•°ç»„ï¼Ÿ
		 * 1. Carte æ„é€ å‡½æ•°ç§æœ‰ï¼Œæ— æ³•ç›´æ¥åˆ›å»ºå¯¹è±¡æ•°ç»„
		 * 2. æŒ‡é’ˆå…è®¸åŠ¨æ€åˆ†é…ï¼ˆnewï¼‰ï¼Œåœ¨è¿è¡Œæ—¶åˆ›å»º
		 * 3. çµæ´»æ€§ï¼šå¯ä»¥åœ¨æ„é€ å‡½æ•°ä¸­é€ä¸ªåˆ›å»ºå¡ç‰Œ
		 */
		const Carte *cartes[config::NB_CARTES];

		// ====================================================================
		// ç¦ç”¨æ‹·è´å’Œèµ‹å€¼ (Deleted Copy and Assignment)
		// ====================================================================

		/**
		 * æ‹·è´æ„é€ å‡½æ•°ï¼šå·²åˆ é™¤
		 *
		 * ä¸ºä»€ä¹ˆåˆ é™¤ï¼Ÿ
		 * - å•ä¾‹æ¨¡å¼ï¼šä¸å…è®¸åˆ›å»ºå¤šä¸ª Jeu å®ä¾‹
		 * - èµ„æºç®¡ç†ï¼šé¿å…å¤šä¸ªå¯¹è±¡ç®¡ç†åŒä¸€æ‰¹åŠ¨æ€åˆ†é…çš„ Carte
		 * - é˜²æ­¢é”™è¯¯ï¼šæ‹·è´ä¼šå¯¼è‡´ä¸¤ä¸ª Jeu å¯¹è±¡æŒ‡å‘ç›¸åŒçš„ Carteï¼Œ
		 *   é”€æ¯æ—¶ä¼šé‡å¤é‡Šæ”¾å†…å­˜ï¼ˆdouble freeï¼‰
		 */
		Jeu(const Jeu &) = delete;

		/**
		 * èµ‹å€¼è¿ç®—ç¬¦ï¼šå·²åˆ é™¤
		 * åŸå› åŒä¸Šï¼Œç»´æŠ¤å•ä¾‹æ¨¡å¼
		 */
		Jeu &operator=(const Jeu &) = delete;

		// ====================================================================
		// ç§æœ‰æ„é€ å’Œææ„å‡½æ•° (Private Constructor and Destructor)
		// ====================================================================

		/**
		 * æ„é€ å‡½æ•°ï¼šåˆ›å»ºæ‰€æœ‰ 81 å¼ å¡ç‰Œ
		 *
		 * ä¸ºä»€ä¹ˆç§æœ‰ï¼Ÿ
		 * - å•ä¾‹æ¨¡å¼è¦æ±‚ï¼šå¤–éƒ¨æ— æ³•ç›´æ¥åˆ›å»ºå®ä¾‹
		 * - åªèƒ½é€šè¿‡ getInstance() è·å–å”¯ä¸€å®ä¾‹
		 *
		 * ä¸ºä»€ä¹ˆä¸ç”¨ = defaultï¼Ÿ
		 * - éœ€è¦è‡ªå®šä¹‰é€»è¾‘ï¼šç”Ÿæˆæ‰€æœ‰ 81 å¼ ä¸åŒçš„å¡ç‰Œ
		 * - 4å±‚åµŒå¥—å¾ªç¯éå†æ‰€æœ‰ç‰¹å¾ç»„åˆ
		 * - ä¸ºæ¯å¼ å¡ç‰Œåˆ†é…å†…å­˜ï¼ˆnew Carte(...)ï¼‰
		 */
		Jeu();

		/**
		 * ææ„å‡½æ•°ï¼šé‡Šæ”¾æ‰€æœ‰å¡ç‰Œçš„å†…å­˜
		 *
		 * ä¸ºä»€ä¹ˆä¸ç”¨ = defaultï¼Ÿ
		 * - éœ€è¦è‡ªå®šä¹‰æ¸…ç†ï¼šé‡Šæ”¾ 81 å¼ åŠ¨æ€åˆ†é…çš„ Carte
		 * - éµå¾ª"è°åˆ†é…è°é‡Šæ”¾"åŸåˆ™
		 * - é˜²æ­¢å†…å­˜æ³„æ¼ï¼šå¿…é¡» delete æ¯ä¸ª new å‡ºæ¥çš„ Carte
		 */
		~Jeu();

	public:
		// ====================================================================
		// å•ä¾‹è®¿é—®æ–¹æ³• (Singleton Access Method)
		// ====================================================================

		/**
		 * getInstance: è·å– Jeu çš„å”¯ä¸€å®ä¾‹ï¼ˆå•ä¾‹æ¨¡å¼ï¼‰
		 *
		 * å®ç°åŸç†ï¼š
		 * - static å±€éƒ¨å˜é‡ï¼šåœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶åˆ›å»ºï¼Œç¨‹åºç»“æŸæ—¶é”€æ¯
		 * - çº¿ç¨‹å®‰å…¨ï¼šC++11 ä¿è¯ static å±€éƒ¨å˜é‡çš„åˆå§‹åŒ–æ˜¯çº¿ç¨‹å®‰å…¨çš„
		 * - å»¶è¿Ÿåˆå§‹åŒ–ï¼šåªæœ‰åœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨æ—¶æ‰åˆ›å»ºå®ä¾‹
		 *
		 * å•ä¾‹æ¨¡å¼çš„ä¼˜ç‚¹ï¼š
		 * - å…¨å±€è®¿é—®ç‚¹ï¼šä»»ä½•åœ°æ–¹éƒ½å¯ä»¥è·å– Jeu å®ä¾‹
		 * - èµ„æºå…±äº«ï¼šæ‰€æœ‰ä»£ç å…±äº«åŒä¸€å¥—å¡ç‰Œæ•°æ®
		 * - å†…å­˜é«˜æ•ˆï¼šåªåˆ›å»ºä¸€æ¬¡ï¼Œé¿å…é‡å¤åˆ›å»º
		 *
		 * ä½¿ç”¨æ–¹å¼ï¼š
		 *   Jeu& jeu = Jeu::getInstance();
		 *   const Carte& card = jeu.getCarte(0);
		 */
		static Jeu &getInstance()
		{
			static Jeu instance; // å±€éƒ¨é™æ€å˜é‡ï¼Œåªåˆå§‹åŒ–ä¸€æ¬¡
			return instance;	 // è¿”å›å¼•ç”¨ï¼Œé¿å…æ‹·è´
		}

		// ====================================================================
		// å…¬æœ‰è®¿é—®æ–¹æ³• (Public Access Methods)
		// ====================================================================

		/**
		 * getCarte: è·å–æŒ‡å®šç´¢å¼•çš„å¡ç‰Œ
		 *
		 * å‚æ•°ï¼š
		 * - i: å¡ç‰Œç´¢å¼•ï¼ˆ0-80ï¼‰
		 *   size_t æ˜¯æ— ç¬¦å·æ•´æ•°ç±»å‹ï¼Œè¡¨ç¤ºå¤§å°å’Œç´¢å¼•
		 *   åœ¨ 64 ä½ç³»ç»Ÿä¸Šé€šå¸¸æ˜¯ unsigned long (8 å­—èŠ‚)
		 *   åœ¨ 32 ä½ç³»ç»Ÿä¸Šé€šå¸¸æ˜¯ unsigned int (4 å­—èŠ‚)
		 *
		 * è¿”å›å€¼ï¼šconst Carte&
		 * - å¼•ç”¨ï¼šé¿å…æ‹·è´ï¼Œæé«˜æ•ˆç‡
		 * - constï¼šä¿è¯å¤–éƒ¨æ— æ³•ä¿®æ”¹å¡ç‰Œ
		 *
		 * å¼‚å¸¸ï¼šå¦‚æœ i >= 81ï¼ŒæŠ›å‡º SetException
		 *
		 * const æˆå‘˜å‡½æ•°ï¼šä¸ä¿®æ”¹ Jeu å¯¹è±¡çš„çŠ¶æ€
		 */
		const Carte &getCarte(size_t i) const;

		/**
		 * getNbCartes: è·å–å¡ç‰Œæ€»æ•°
		 *
		 * è¿”å›å€¼ï¼š81ï¼ˆé€šè¿‡é…ç½®æ–‡ä»¶ç»Ÿä¸€ç®¡ç†ï¼‰
		 *
		 * è®¾è®¡ä¼˜åŠ¿ï¼š
		 * - ä½¿ç”¨ config::NB_CARTES è€Œä¸æ˜¯ç¡¬ç¼–ç  81
		 * - é›†ä¸­ç®¡ç†å¸¸é‡ï¼Œä¾¿äºç»´æŠ¤å’Œä¿®æ”¹
		 * - æé«˜ä»£ç å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§
		 */
		size_t getNbCartes() const { return config::NB_CARTES; }

		// ================================================================
		// è¿­ä»£å™¨ç±»ï¼šéå†æ‰€æœ‰å¡ç‰Œ (Iterator Classes)
		// ================================================================

		/**
		 * Iterator: åŸºäºæŒ‡é’ˆçš„è¿­ä»£å™¨ï¼ˆæ–¹å¼ä¸€ï¼‰
		 *
		 * è®¾è®¡æ¨¡å¼ï¼šè¿­ä»£å™¨æ¨¡å¼ (Iterator Pattern)
		 * ç›®çš„ï¼šæä¾›ä¸€ç§æ–¹æ³•é¡ºåºè®¿é—®èšåˆå¯¹è±¡ä¸­çš„å…ƒç´ ï¼Œ
		 *      è€Œä¸æš´éœ²å…¶å†…éƒ¨è¡¨ç¤º
		 *
		 * å®ç°æ–¹å¼ï¼šä½¿ç”¨æŒ‡å‘æŒ‡é’ˆçš„æŒ‡é’ˆ
		 * - currentCarte: æŒ‡å‘ cartes æ•°ç»„ä¸­å½“å‰å…ƒç´ çš„æŒ‡é’ˆ
		 * - nb: å‰©ä½™å¯è¿­ä»£çš„å…ƒç´ æ•°é‡
		 *
		 * ä¸ºä»€ä¹ˆæ˜¯ const Carte**ï¼Ÿ
		 * - cartes æ˜¯ const Carte* ç±»å‹çš„æ•°ç»„
		 * - currentCarte éœ€è¦æŒ‡å‘æ•°ç»„å…ƒç´ ï¼ˆæŒ‡é’ˆçš„æŒ‡é’ˆï¼‰
		 * - ä¿æŒ const çº¦æŸï¼Œé˜²æ­¢ä¿®æ”¹å¡ç‰Œ
		 *
		 * ä½¿ç”¨ç¤ºä¾‹ï¼š
		 *   Jeu::Iterator it = jeu.first();
		 *   while (!it.isDone()) {
		 *       cout << it.getCurrentItem();
		 *       it.next();
		 *   }
		 */
		class Iterator
		{
		private:
			const Carte **currentCarte; // æŒ‡å‘å½“å‰å¡ç‰ŒæŒ‡é’ˆçš„æŒ‡é’ˆ
			size_t nb;					// å‰©ä½™å¾…éå†çš„å¡ç‰Œæ•°é‡

			/**
			 * ç§æœ‰æ„é€ å‡½æ•°ï¼šåªå…è®¸ Jeu åˆ›å»ºè¿­ä»£å™¨
			 *
			 * å‚æ•°ï¼š
			 * - c: æŒ‡å‘æ•°ç»„èµ·å§‹ä½ç½®çš„æŒ‡é’ˆ
			 * - n: å¯è¿­ä»£çš„å…ƒç´ æ•°é‡
			 */
			Iterator(const Carte **c, size_t n) : currentCarte(c), nb(n) {}

			friend class Jeu; // å…è®¸ Jeu è®¿é—®ç§æœ‰æ„é€ å‡½æ•°

		public:
			/**
			 * next: ç§»åŠ¨åˆ°ä¸‹ä¸€å¼ å¡ç‰Œ
			 *
			 * æ“ä½œï¼š
			 * 1. currentCarte++ : æŒ‡é’ˆå‘åç§»åŠ¨ä¸€ä½
			 * 2. nb-- : å‰©ä½™æ•°é‡å‡ä¸€
			 */
			void next()
			{
				currentCarte++; // ç§»åŠ¨æŒ‡é’ˆåˆ°ä¸‹ä¸€ä¸ªå…ƒç´ 
				nb--;			// å‡å°‘å‰©ä½™è®¡æ•°
			}

			/**
			 * isDone: æ£€æŸ¥æ˜¯å¦éå†å®Œæˆ
			 *
			 * è¿”å›ï¼štrue è¡¨ç¤ºå·²éå†å®Œæ‰€æœ‰å…ƒç´ 
			 */
			bool isDone() const { return nb == 0; }

			/**
			 * getCurrentItem: è·å–å½“å‰å¡ç‰Œ
			 *
			 * è¿”å›ï¼šå½“å‰æŒ‡å‘çš„ Carte å¯¹è±¡çš„å¼•ç”¨
			 *
			 * ä¸ºä»€ä¹ˆæ˜¯ **currentCarteï¼Ÿ
			 * - currentCarte æ˜¯æŒ‡å‘æŒ‡é’ˆçš„æŒ‡é’ˆï¼ˆCarte**ï¼‰
			 * - *currentCarte å¾—åˆ° Carte*ï¼ˆæŒ‡å‘ Carte çš„æŒ‡é’ˆï¼‰
			 * - **currentCarte å¾—åˆ° Carte å¯¹è±¡æœ¬èº«
			 */
			const Carte &getCurrentItem() const
			{
				return **currentCarte; // åŒé‡è§£å¼•ç”¨è·å– Carte å¯¹è±¡
			}
		};

		/**
		 * first: åˆ›å»ºæŒ‡å‘ç¬¬ä¸€å¼ å¡ç‰Œçš„è¿­ä»£å™¨
		 *
		 * è¿”å›ï¼šæŒ‡å‘æ•°ç»„å¼€å¤´çš„ Iterator
		 *
		 * å®ç°ç»†èŠ‚ï¼š
		 * - &cartes[0] è·å–æ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ çš„åœ°å€
		 * - åˆå§‹åŒ– nb ä¸ºæ€»å¡ç‰Œæ•°
		 */
		Iterator first()
		{
			const Carte **c = &cartes[0]; // è·å–æ•°ç»„é¦–åœ°å€
			return Iterator(c, config::NB_CARTES);
		}

		/**
		 * IteratorBis: åŸºäºç´¢å¼•çš„è¿­ä»£å™¨ï¼ˆæ–¹å¼äºŒï¼‰
		 *
		 * å¯¹æ¯” Iterator çš„ä¸åŒï¼š
		 * - Iterator ä½¿ç”¨æŒ‡é’ˆéå†ï¼šcurrentCarte++
		 * - IteratorBis ä½¿ç”¨ç´¢å¼•éå†ï¼ši++
		 *
		 * ä¼˜ç¼ºç‚¹å¯¹æ¯”ï¼š
		 * Iteratorï¼ˆæŒ‡é’ˆæ–¹å¼ï¼‰ï¼š
		 *   ä¼˜ç‚¹ï¼šç›´æ¥æ“ä½œæŒ‡é’ˆï¼Œæ•ˆç‡ç•¥é«˜
		 *   ç¼ºç‚¹ï¼šéœ€è¦ç†è§£æŒ‡é’ˆçš„æŒ‡é’ˆï¼Œè¾ƒå¤æ‚
		 *
		 * IteratorBisï¼ˆç´¢å¼•æ–¹å¼ï¼‰ï¼š
		 *   ä¼˜ç‚¹ï¼šé€»è¾‘æ›´æ¸…æ™°ï¼Œæ˜“äºç†è§£
		 *   ç¼ºç‚¹ï¼šæ¯æ¬¡éœ€è¦é€šè¿‡ getCarte(i) è®¿é—®ï¼Œå¤šä¸€æ¬¡å‡½æ•°è°ƒç”¨
		 *
		 * è®¾è®¡æ„å›¾ï¼š
		 * å±•ç¤ºä¸¤ç§ä¸åŒçš„è¿­ä»£å™¨å®ç°æ–¹å¼ï¼Œè®©å­¦ä¹ è€…ç†è§£ï¼š
		 * - è¿­ä»£å™¨æ¨¡å¼çš„æœ¬è´¨æ˜¯æä¾›ç»Ÿä¸€çš„éå†æ¥å£
		 * - åº•å±‚å®ç°å¯ä»¥æœ‰å¤šç§æ–¹å¼
		 */
		class IteratorBis
		{
		private:
			Jeu &instance; // Jeu å®ä¾‹çš„å¼•ç”¨
			size_t i;	   // å½“å‰å¡ç‰Œçš„ç´¢å¼•

			/**
			 * æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–è¿­ä»£å™¨
			 *
			 * å‚æ•°ï¼š
			 * - j: Jeu å¯¹è±¡çš„å¼•ç”¨
			 * - index: èµ·å§‹ç´¢å¼•
			 */
			IteratorBis(Jeu &j, size_t index) : instance(j), i(index) {}

			friend class Jeu;

		public:
			/**
			 * next: ç§»åŠ¨åˆ°ä¸‹ä¸€å¼ å¡ç‰Œ
			 *
			 * å®‰å…¨æ£€æŸ¥ï¼šå¦‚æœå·²ç»éå†å®Œæˆï¼ŒæŠ›å‡ºå¼‚å¸¸
			 * è¿™æ˜¯ä¸€ç§é˜²å¾¡æ€§ç¼–ç¨‹çš„ä½“ç°
			 */
			void next()
			{
				if (isDone())
					throw SetException("end of iteration");
				i++; // ç´¢å¼•é€’å¢
			}

			/**
			 * isDone: æ£€æŸ¥æ˜¯å¦éå†å®Œæˆ
			 *
			 * åˆ¤æ–­ï¼šå½“å‰ç´¢å¼•æ˜¯å¦è¾¾åˆ°æ€»æ•°
			 */
			bool isDone() const { return i == instance.getNbCartes(); }

			/**
			 * getCurrentItem: è·å–å½“å‰å¡ç‰Œ
			 *
			 * å®ç°ï¼šé€šè¿‡ç´¢å¼•è°ƒç”¨ getCarte(i)
			 * åŒ…å«å®‰å…¨æ£€æŸ¥ï¼Œé˜²æ­¢è¶Šç•Œè®¿é—®
			 */
			const Carte &getCurrentItem() const
			{
				if (isDone())
					throw SetException("end of iteration");
				return instance.getCarte(i); // é€šè¿‡ç´¢å¼•è·å–å¡ç‰Œ
			}
		};

		/**
		 * firstBis: åˆ›å»ºæŒ‡å‘ç¬¬ä¸€å¼ å¡ç‰Œçš„ IteratorBis
		 *
		 * å‚æ•°ï¼š*this ä¼ é€’å½“å‰ Jeu å¯¹è±¡çš„å¼•ç”¨
		 * ç´¢å¼•ä» 0 å¼€å§‹
		 */
		IteratorBis firstBis()
		{
			return IteratorBis(*this, 0);
		}

		/**
		 * const_iterator: ç¬¦åˆ C++ æ ‡å‡†åº“é£æ ¼çš„è¿­ä»£å™¨
		 *
		 * è®¾è®¡ç›®æ ‡ï¼š
		 * - å…¼å®¹ C++11 çš„ range-based for å¾ªç¯
		 * - éµå¾ª STL å®¹å™¨çš„è¿­ä»£å™¨æ¥å£è§„èŒƒ
		 *
		 * å¿…é¡»å®ç°çš„æ“ä½œç¬¦ï¼š
		 * - operator++: å‰ç¼€é€’å¢è¿ç®—ç¬¦
		 * - operator!=: ä¸ç­‰äºæ¯”è¾ƒè¿ç®—ç¬¦
		 * - operator*: è§£å¼•ç”¨è¿ç®—ç¬¦
		 *
		 * é…åˆ begin() å’Œ end()ï¼Œæ”¯æŒä»¥ä¸‹è¯­æ³•ï¼š
		 *   for (const Carte& c : jeu) {
		 *       cout << c << endl;
		 *   }
		 *
		 * ä¸ºä»€ä¹ˆå« const_iteratorï¼Ÿ
		 * - è¿”å›çš„æ˜¯ const Carte&ï¼Œä¸å…è®¸ä¿®æ”¹å¡ç‰Œ
		 * - å¯¹åº” STL ä¸­çš„ const_iterator æ¦‚å¿µ
		 * - ä¸ iteratorï¼ˆé constï¼‰åŒºåˆ†å¼€
		 */
		class const_iterator
		{
		private:
			const Jeu &instance; // Jeu å®ä¾‹çš„ const å¼•ç”¨
			size_t i;			 // å½“å‰ç´¢å¼•

			/**
			 * æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–è¿­ä»£å™¨ä½ç½®
			 *
			 * å‚æ•°ï¼š
			 * - j: const Jeu å¼•ç”¨ï¼ˆä¿è¯ä¸ä¿®æ”¹ Jeuï¼‰
			 * - index: èµ·å§‹ç´¢å¼•
			 */
			const_iterator(const Jeu &j, size_t index) : instance(j), i(index) {}

			friend class Jeu;

		public:
			/**
			 * operator++: å‰ç¼€é€’å¢è¿ç®—ç¬¦
			 *
			 * ç”¨æ³•ï¼š++it
			 *
			 * ä¸ºä»€ä¹ˆä¸è¿”å›å€¼ï¼Ÿ
			 * - ç®€åŒ–å®ç°ï¼Œæ»¡è¶³åŸºæœ¬ range-based for éœ€æ±‚
			 * - æ ‡å‡†å®ç°åº”è¿”å› const_iterator&
			 */
			void operator++()
			{
				i++;
			}

			/**
			 * operator!=: ä¸ç­‰äºæ¯”è¾ƒè¿ç®—ç¬¦
			 *
			 * ç”¨é€”ï¼šrange-based for å¾ªç¯åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ end()
			 *
			 * å®ç°ï¼šæ¯”è¾ƒç´¢å¼•æ˜¯å¦ä¸åŒ
			 *
			 * æ³¨æ„ï¼šé€šå¸¸è¿˜åº”è¯¥æ£€æŸ¥æ˜¯å¦æ¯”è¾ƒçš„æ˜¯åŒä¸€ä¸ªå®¹å™¨çš„è¿­ä»£å™¨
			 *      è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œåªæ¯”è¾ƒç´¢å¼•
			 */
			bool operator!=(const_iterator other) const
			{
				return i != other.i;
			}

			/**
			 * operator*: è§£å¼•ç”¨è¿ç®—ç¬¦
			 *
			 * ç”¨æ³•ï¼š*it æˆ– auto& card = *it
			 *
			 * è¿”å›ï¼šå½“å‰ä½ç½®çš„ Carte å¼•ç”¨
			 *
			 * æ¨¡æ‹ŸæŒ‡é’ˆè¡Œä¸ºï¼šå°±åƒ *ptr è·å–æŒ‡é’ˆæŒ‡å‘çš„å€¼
			 */
			const Carte &operator*() const
			{
				return instance.getCarte(i);
			}
		};

		/**
		 * begin: è¿”å›æŒ‡å‘ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨
		 *
		 * å¿…é¡»æ˜¯ const æˆå‘˜å‡½æ•°ï¼Œé…åˆ range-based for
		 */
		const_iterator begin() const { return const_iterator(*this, 0); }

		/**
		 * end: è¿”å›æŒ‡å‘"æœ€åä¸€ä¸ªå…ƒç´ ä¹‹å"çš„è¿­ä»£å™¨
		 *
		 * æ³¨æ„ï¼šend() ä¸æŒ‡å‘æœ‰æ•ˆå…ƒç´ ï¼Œä»…ç”¨äºåˆ¤æ–­ç»“æŸ
		 * ç»å…¸çš„"å“¨å…µ"æ¨¡å¼ï¼Œ[begin, end) å·¦é—­å³å¼€åŒºé—´
		 */
		const_iterator end() const { return const_iterator(*this, config::NB_CARTES); }

		/**
		 * FormeIterator: æ¡ä»¶è¿‡æ»¤è¿­ä»£å™¨
		 *
		 * è®¾è®¡ç›®çš„ï¼š
		 * - åªéå†ç‰¹å®šå½¢çŠ¶ï¼ˆFormeï¼‰çš„å¡ç‰Œ
		 * - å±•ç¤ºè¿­ä»£å™¨çš„æ‰©å±•åº”ç”¨ï¼šå¸¦è¿‡æ»¤æ¡ä»¶çš„éå†
		 *
		 * åº”ç”¨åœºæ™¯ï¼š
		 * - éœ€è¦æŸ¥æ‰¾æ‰€æœ‰æ¤­åœ†å½¢å¡ç‰Œ
		 * - éœ€è¦æŸ¥æ‰¾æ‰€æœ‰æ³¢æµªå½¢å¡ç‰Œ
		 * - ä»»ä½•åŸºäºå½¢çŠ¶çš„è¿‡æ»¤æŸ¥è¯¢
		 *
		 * å®ç°åŸç†ï¼š
		 * - åœ¨ next() ä¸­è·³è¿‡ä¸ç¬¦åˆæ¡ä»¶çš„å¡ç‰Œ
		 * - æŒç»­é€’å¢ç´¢å¼•ç›´åˆ°æ‰¾åˆ°åŒ¹é…çš„å½¢çŠ¶æˆ–éå†å®Œæˆ
		 *
		 * æ‰©å±•æ€è·¯ï¼š
		 * - å¯ä»¥å®ç° CouleurIteratorï¼ˆæŒ‰é¢œè‰²è¿‡æ»¤ï¼‰
		 * - å¯ä»¥å®ç° NombreIteratorï¼ˆæŒ‰æ•°é‡è¿‡æ»¤ï¼‰
		 * - å¯ä»¥å®ç°é€šç”¨çš„ FilterIteratorï¼ˆä¼ å…¥è°“è¯å‡½æ•°ï¼‰
		 *
		 * ä½¿ç”¨ç¤ºä¾‹ï¼š
		 *   // éå†æ‰€æœ‰æ¤­åœ†å½¢å¡ç‰Œ
		 *   FormeIterator it = jeu.firstFormeIterator(Forme::ovale);
		 *   while (!it.isDone()) {
		 *       cout << it.getCurrentItem();
		 *       it.next();
		 *   }
		 */
		class FormeIterator
		{
		private:
			Forme forme;   // è¦è¿‡æ»¤çš„å½¢çŠ¶
			Jeu &instance; // Jeu å®ä¾‹å¼•ç”¨
			size_t i;	   // å½“å‰ç´¢å¼•

			/**
			 * æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–è¿‡æ»¤è¿­ä»£å™¨
			 *
			 * å‚æ•°ï¼š
			 * - j: Jeu å¯¹è±¡å¼•ç”¨
			 * - index: èµ·å§‹ç´¢å¼•
			 * - f: è¦è¿‡æ»¤çš„å½¢çŠ¶
			 */
			FormeIterator(Jeu &j, size_t index, Forme f)
				: forme(f), instance(j), i(index) {}

			friend class Jeu;

		public:
			/**
			 * next: ç§»åŠ¨åˆ°ä¸‹ä¸€å¼ ç¬¦åˆæ¡ä»¶çš„å¡ç‰Œ
			 *
			 * ç®—æ³•ï¼š
			 * 1. å…ˆé€’å¢ç´¢å¼•ï¼ˆi++ï¼‰
			 * 2. å¦‚æœæœªå®Œæˆä¸”å½“å‰å¡ç‰Œå½¢çŠ¶ä¸åŒ¹é…ï¼Œç»§ç»­é€’å¢
			 * 3. ç›´åˆ°æ‰¾åˆ°åŒ¹é…çš„å¡ç‰Œæˆ–éå†å®Œæˆ
			 *
			 * æ—¶é—´å¤æ‚åº¦ï¼š
			 * - æœ€å O(n)ï¼Œéœ€è¦éå†æ‰€æœ‰å¡ç‰Œ
			 * - å¹³å‡ O(1)ï¼Œå› ä¸ºæ¯ç§å½¢çŠ¶çº¦å  1/3
			 */
			void next()
			{
				i++; // ç§»åŠ¨åˆ°ä¸‹ä¸€å¼ å¡
				// è·³è¿‡ä¸ç¬¦åˆæ¡ä»¶çš„å¡ç‰Œ
				while (!isDone() &&
					   instance.getCarte(i).getForme() != forme)
					i++;
			}

			/**
			 * isDone: æ£€æŸ¥æ˜¯å¦éå†å®Œæˆ
			 */
			bool isDone() const { return i == instance.getNbCartes(); }

			/**
			 * getCurrentItem: è·å–å½“å‰å¡ç‰Œ
			 *
			 * å‰æï¼šå½“å‰ç´¢å¼•æŒ‡å‘çš„å¡ç‰Œå½¢çŠ¶åŒ¹é… forme
			 */
			const Carte &getCurrentItem() const
			{
				return instance.getCarte(i);
			}
		};

		/**
		 * firstFormeIterator: åˆ›å»ºå½¢çŠ¶è¿‡æ»¤è¿­ä»£å™¨
		 *
		 * å‚æ•°ï¼š
		 * - f: è¦è¿‡æ»¤çš„å½¢çŠ¶
		 *
		 * è¿”å›ï¼šæŒ‡å‘ç¬¬ä¸€å¼ è¯¥å½¢çŠ¶å¡ç‰Œçš„è¿­ä»£å™¨
		 *
		 * æ³¨æ„ï¼šå¦‚æœç¬¬ä¸€å¼ å¡ä¸æ˜¯ç›®æ ‡å½¢çŠ¶ï¼Œ
		 *      ç”¨æˆ·éœ€è¦å…ˆè°ƒç”¨ next() æ‰èƒ½æ‰¾åˆ°ç¬¬ä¸€å¼ åŒ¹é…çš„å¡
		 */
		FormeIterator firstFormeIterator(Forme f)
		{
			return FormeIterator(*this, 0, f);
		}
	}; // end of class Jeu

	// ========================================================================
	// Pioche ç±»ï¼šç‰Œå †ç®¡ç†ç±» (Draw Pile Class)
	// ========================================================================

	/**
	 * Pioche: ç®¡ç†å¾…å‘çš„å¡ç‰Œï¼ˆç‰Œå †ï¼‰
	 *
	 * è®¾è®¡è¦ç‚¹ï¼ˆå›ç­”é¢˜ç›®é—®é¢˜6ã€7ï¼‰ï¼š
	 *
	 * é—®é¢˜6ï¼šCarte ä¸ Pioche çš„å…³ç³»
	 * - èšåˆå…³ç³»ï¼ˆAggregationï¼Œç©ºå¿ƒè±å½¢ï¼‰
	 * - Pioche æŒæœ‰æŒ‡å‘ Carte çš„æŒ‡é’ˆï¼Œä½†ä¸æ‹¥æœ‰ Carte
	 * - Carte çš„ç”Ÿå‘½å‘¨æœŸç”± Jeu ç®¡ç†ï¼Œä¸å— Pioche å½±å“
	 * - Pioche é”€æ¯æ—¶ä¸åº”è¯¥åˆ é™¤ Carte å¯¹è±¡
	 * - UMLè¡¨ç¤ºï¼šPioche â—‡â€”â€”> Carte (1å¯¹å¤šçš„èšåˆ)
	 *
	 * ç»„åˆ vs èšåˆçš„åŒºåˆ«ï¼š
	 * - Jeu â—†â€”â€”> Carte: ç»„åˆï¼ŒJeu æ‹¥æœ‰ Carteï¼Œè´Ÿè´£åˆ›å»ºå’Œé”€æ¯
	 * - Pioche â—‡â€”â€”> Carte: èšåˆï¼ŒPioche å¼•ç”¨ Carteï¼Œä¸è´Ÿè´£ç”Ÿå‘½å‘¨æœŸ
	 *
	 * é—®é¢˜7ï¼šexplicit å…³é”®å­—çš„æ„ä¹‰
	 * - é˜²æ­¢éšå¼ç±»å‹è½¬æ¢
	 * - explicit Pioche(const Jeu& j) ç¦æ­¢ï¼šPioche p = jeu;
	 * - å¿…é¡»æ˜¾å¼è°ƒç”¨ï¼šPioche p(jeu);
	 * - é¿å…æ„å¤–çš„ç±»å‹è½¬æ¢å¯¼è‡´çš„é”™è¯¯
	 *
	 * ä¸ºä»€ä¹ˆç¦æ­¢æ‹·è´ï¼Ÿ
	 * - èµ„æºç®¡ç†ï¼šé¿å…å¤šä¸ª Pioche ç®¡ç†åŒä¸€ä¸ªåŠ¨æ€æ•°ç»„
	 * - é˜²æ­¢æ‚¬ç©ºæŒ‡é’ˆï¼šæ‹·è´ä¼šå¯¼è‡´ä¸¤ä¸ªå¯¹è±¡å…±äº«æŒ‡é’ˆæ•°ç»„
	 * - æ˜ç¡®è¯­ä¹‰ï¼šä¸€ä¸ªæ¸¸æˆåªåº”è¯¥æœ‰ä¸€ä¸ªç‰Œå †
	 *
	 * åŠŸèƒ½è¯´æ˜ï¼š
	 * - åˆå§‹åŒ–æ—¶åŒ…å«æ‰€æœ‰ 81 å¼ å¡ç‰Œ
	 * - piocher() éšæœºæŠ½å–ä¸€å¼ å¡å¹¶å°†å…¶ä»ç‰Œå †ç§»é™¤
	 * - æ”¯æŒæŸ¥è¯¢å‰©ä½™å¡ç‰Œæ•°é‡å’Œæ˜¯å¦ä¸ºç©º
	 */
	class Pioche
	{
	private:
		// ====================================================================
		// ç§æœ‰æˆå‘˜å˜é‡ (Private Member Variables)
		// ====================================================================

		/**
		 * cartes: æŒ‡å‘å¡ç‰ŒæŒ‡é’ˆçš„åŠ¨æ€æ•°ç»„
		 *
		 * ç±»å‹åˆ†æï¼šconst Carte**
		 * - æœ€å†…å±‚ï¼šCarte å¯¹è±¡
		 * - ä¸­é—´å±‚ï¼šconst Carte* ï¼ˆæŒ‡å‘ Carte çš„å¸¸é‡æŒ‡é’ˆï¼‰
		 * - å¤–å±‚ï¼šconst Carte** ï¼ˆæŒ‡å‘æŒ‡é’ˆçš„æŒ‡é’ˆï¼Œå³æŒ‡é’ˆæ•°ç»„ï¼‰
		 *
		 * ä¸ºä»€ä¹ˆæ˜¯åŠ¨æ€æ•°ç»„ï¼Ÿ
		 * - åˆå§‹åŒ–æ—¶ä» Jeu å¤åˆ¶æ‰€æœ‰å¡ç‰Œçš„åœ°å€
		 * - éœ€è¦å¯ä¿®æ”¹çš„æ•°ç»„æ¥å®ç°"æŠ½ç‰Œ"æ“ä½œ
		 * - æŠ½åˆ°çš„ç‰Œä¼šä»æ•°ç»„ä¸­ç§»é™¤ï¼ˆäº¤æ¢åˆ°æœ«å°¾ï¼‰
		 */
		const Carte **cartes;

		/**
		 * nb: å½“å‰ç‰Œå †ä¸­å‰©ä½™çš„å¡ç‰Œæ•°é‡
		 *
		 * åˆå§‹å€¼ï¼š81ï¼ˆæ‰€æœ‰å¡ç‰Œï¼‰
		 * æ¯æ¬¡ piocher() åé€’å‡
		 * å½“ nb == 0 æ—¶ç‰Œå †ä¸ºç©º
		 */
		size_t nb;

	public:
		// ====================================================================
		// æ„é€ å‡½æ•° (Constructor)
		// ====================================================================

		/**
		 * æ„é€ å‡½æ•°ï¼šä» Jeu åˆ›å»ºç‰Œå †
		 *
		 * å‚æ•°ï¼š
		 * - j: Jeu å¯¹è±¡çš„å¼•ç”¨ï¼ˆä¸æ˜¯ constï¼Œå› ä¸ºå¯èƒ½éœ€è¦è·å–é const å¼•ç”¨ï¼‰
		 *
		 * æ³¨æ„ï¼šè™½ç„¶å‚æ•°ä¸æ˜¯ explicitï¼Œä½†å»ºè®®åŠ ä¸Šä»¥é˜²æ­¢éšå¼è½¬æ¢
		 *
		 * åˆå§‹åŒ–æ­¥éª¤ï¼š
		 * 1. åˆ†é…å¤§å°ä¸º NB_CARTES çš„æŒ‡é’ˆæ•°ç»„
		 * 2. å°† Jeu ä¸­æ‰€æœ‰å¡ç‰Œçš„åœ°å€å¤åˆ¶åˆ°æ•°ç»„
		 * 3. åˆå§‹åŒ– nb ä¸ºæ€»å¡ç‰Œæ•°
		 *
		 * æ—¶é—´å¤æ‚åº¦ï¼šO(n)ï¼Œn = 81
		 * ç©ºé—´å¤æ‚åº¦ï¼šO(n)ï¼Œåˆ†é… 81 ä¸ªæŒ‡é’ˆ
		 */
		Pioche(Jeu &j) : nb(config::NB_CARTES)
		{
			// åŠ¨æ€åˆ†é…æŒ‡é’ˆæ•°ç»„
			cartes = new const Carte *[config::NB_CARTES];

			// å¤åˆ¶æ‰€æœ‰å¡ç‰Œçš„åœ°å€
			// æ³¨æ„ï¼šè¿™é‡Œåªå¤åˆ¶åœ°å€ï¼ˆæµ…æ‹·è´ï¼‰ï¼Œä¸å¤åˆ¶ Carte å¯¹è±¡
			for (size_t i = 0; i < j.getNbCartes(); i++)
				cartes[i] = &j.getCarte(i);
		}

		// ====================================================================
		// ææ„å‡½æ•° (Destructor)
		// ====================================================================

		/**
		 * ææ„å‡½æ•°ï¼šé‡Šæ”¾åŠ¨æ€åˆ†é…çš„æŒ‡é’ˆæ•°ç»„
		 *
		 * é‡è¦ï¼šåªåˆ é™¤æ•°ç»„æœ¬èº«ï¼Œä¸åˆ é™¤ Carte å¯¹è±¡
		 *
		 * ä¸ºä»€ä¹ˆä¸åˆ é™¤ Carteï¼Ÿ
		 * - èšåˆå…³ç³»ï¼šPioche ä¸æ‹¥æœ‰ Carte
		 * - Carte çš„ç”Ÿå‘½å‘¨æœŸç”± Jeu ç®¡ç†
		 * - åˆ é™¤ Carte ä¼šå¯¼è‡´ Jeu ä¸­çš„æŒ‡é’ˆæ‚¬ç©ºï¼ˆdangling pointerï¼‰
		 *
		 * å¯¹æ¯”ï¼š
		 * - delete[] cartes;     âœ… åˆ é™¤æŒ‡é’ˆæ•°ç»„
		 * - delete[] cartes[i];  âŒ é”™è¯¯ï¼ä¸åº”è¯¥åˆ é™¤ Carte
		 */
		~Pioche()
		{
			delete[] cartes; // åªé‡Šæ”¾æŒ‡é’ˆæ•°ç»„ï¼Œä¸åˆ é™¤ Carte å¯¹è±¡
		}

		// ====================================================================
		// å…¬æœ‰æ–¹æ³• (Public Methods)
		// ====================================================================

		/**
		 * piocher: éšæœºæŠ½å–ä¸€å¼ å¡ç‰Œ
		 *
		 * ç®—æ³•ï¼š
		 * 1. æ£€æŸ¥ç‰Œå †æ˜¯å¦ä¸ºç©ºï¼Œç©ºåˆ™æŠ›å‡ºå¼‚å¸¸
		 * 2. ç”Ÿæˆéšæœºç´¢å¼• iï¼ˆ0 åˆ° nb-1ï¼‰
		 * 3. ä¿å­˜ cartes[i]ï¼ˆè¦è¿”å›çš„å¡ç‰Œï¼‰
		 * 4. å°† cartes[nb-1]ï¼ˆæœ€åä¸€å¼ ï¼‰ç§»åˆ°ä½ç½® i
		 * 5. nb--ï¼ˆå‡å°‘ç‰Œå †å¤§å°ï¼‰
		 * 6. è¿”å›è¢«æŠ½ä¸­çš„å¡ç‰Œ
		 *
		 * æ—¶é—´å¤æ‚åº¦ï¼šO(1)
		 *
		 * ä¸ºä»€ä¹ˆäº¤æ¢è€Œä¸æ˜¯åˆ é™¤ï¼Ÿ
		 * - é¿å…æ•°ç»„å…ƒç´ ç§»åŠ¨ï¼ˆO(n)æ“ä½œï¼‰
		 * - åˆ©ç”¨"æœ€åä¸€å¼ å¡å¡«è¡¥ç©ºä½"æŠ€å·§
		 * - ä¿æŒå‰©ä½™å¡ç‰Œåœ¨æ•°ç»„å‰ nb ä¸ªä½ç½®
		 *
		 * å®ç°åœ¨ set.cpp ä¸­
		 */
		const Carte &piocher();

		/**
		 * getNbCartes: è·å–å‰©ä½™å¡ç‰Œæ•°é‡
		 */
		size_t getNbCartes() const { return nb; }

		/**
		 * estVide: æ£€æŸ¥ç‰Œå †æ˜¯å¦ä¸ºç©º
		 */
		bool estVide() const { return nb == 0; }

		// ====================================================================
		// ç¦ç”¨æ‹·è´å’Œèµ‹å€¼ (Deleted Copy and Assignment)
		// ====================================================================

		/**
		 * æ‹·è´æ„é€ å‡½æ•°ï¼šå·²åˆ é™¤
		 *
		 * ä¸ºä»€ä¹ˆç¦æ­¢ï¼Ÿ
		 * - é¿å…æµ…æ‹·è´é—®é¢˜ï¼šä¸¤ä¸ª Pioche ä¼šå…±äº«åŒä¸€ä¸ª cartes æ•°ç»„
		 * - é˜²æ­¢åŒé‡é‡Šæ”¾ï¼šä¸¤ä¸ªå¯¹è±¡çš„ææ„å‡½æ•°ä¼šåˆ é™¤åŒä¸€ä¸ªæ•°ç»„
		 * - è¯­ä¹‰ä¸æ˜ï¼šå¤åˆ¶ç‰Œå †çš„æ„ä¹‰ä¸æ¸…æ™°
		 */
		Pioche(const Pioche &p) = delete;

		/**
		 * èµ‹å€¼è¿ç®—ç¬¦ï¼šå·²åˆ é™¤
		 * åŸå› åŒä¸Š
		 */
		Pioche &operator=(const Pioche &p) = delete;
	};

	// ========================================================================
	// Plateau ç±»ï¼šæ¸¸æˆæ¡Œé¢ç±» (Game Board Class)
	// ========================================================================

	/**
	 * Plateau: è¡¨ç¤ºæ¸¸æˆæ¡Œé¢ï¼Œå­˜æ”¾å½“å‰å¯è§çš„å¡ç‰Œ
	 *
	 * è®¾è®¡è¦ç‚¹ï¼ˆå›ç­”é¢˜ç›®é—®é¢˜8ã€9ï¼‰ï¼š
	 *
	 * é—®é¢˜8ï¼šCarte ä¸ Plateau çš„å…³ç³»
	 * - èšåˆå…³ç³»ï¼ˆAggregationï¼Œç©ºå¿ƒè±å½¢ï¼‰
	 * - Plateau æŒæœ‰æŒ‡å‘ Carte çš„æŒ‡é’ˆï¼Œä½†ä¸æ‹¥æœ‰ Carte
	 * - Carte çš„ç”Ÿå‘½å‘¨æœŸç”± Jeu ç®¡ç†
	 * - Plateau é”€æ¯æ—¶ä¸åˆ é™¤ Carte å¯¹è±¡
	 * - UMLè¡¨ç¤ºï¼šPlateau â—‡â€”â€”> Carte (1å¯¹å¤šçš„èšåˆ)
	 *
	 * é—®é¢˜9ï¼šä¸ºä»€ä¹ˆéœ€è¦è‡ªå®šä¹‰æ‹·è´æ„é€ å’Œèµ‹å€¼è¿ç®—ç¬¦ï¼Ÿ
	 *
	 * å¦‚æœä½¿ç”¨é»˜è®¤ç‰ˆæœ¬ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ
	 * - æµ…æ‹·è´ï¼šä¸¤ä¸ª Plateau å¯¹è±¡çš„ cartes æŒ‡é’ˆæŒ‡å‘åŒä¸€ä¸ªæ•°ç»„
	 * - ä¿®æ”¹ä¸€ä¸ªä¼šå½±å“å¦ä¸€ä¸ª
	 * - ææ„æ—¶ä¼šåŒé‡é‡Šæ”¾åŒä¸€å—å†…å­˜ï¼ˆdouble freeï¼‰â†’ å´©æºƒ
	 *
	 * æ­£ç¡®åšæ³•ï¼š
	 * - æ·±æ‹·è´ï¼šåˆ†é…æ–°çš„æ•°ç»„ï¼Œå¤åˆ¶æ‰€æœ‰æŒ‡é’ˆ
	 * - æ¯ä¸ª Plateau æ‹¥æœ‰ç‹¬ç«‹çš„æ•°ç»„
	 * - ä½†æ•°ç»„ä¸­çš„æŒ‡é’ˆä»æŒ‡å‘ Jeu ä¸­çš„ Carteï¼ˆèšåˆå…³ç³»ï¼‰
	 *
	 * åŠ¨æ€æ•°ç»„è®¾è®¡ï¼š
	 * - cartes: åŠ¨æ€åˆ†é…çš„æŒ‡é’ˆæ•°ç»„
	 * - nbMax: æ•°ç»„çš„å®¹é‡ï¼ˆå·²åˆ†é…çš„å¤§å°ï¼‰
	 * - nb: å½“å‰å®é™…ä½¿ç”¨çš„å…ƒç´ æ•°é‡
	 * - å½“ nb == nbMax æ—¶éœ€è¦æ‰©å®¹
	 *
	 * æ‰©å®¹ç­–ç•¥ï¼š
	 * - æ¯æ¬¡å¢åŠ å›ºå®šå¤§å°ï¼ˆå¦‚ 5ï¼‰
	 * - ç±»ä¼¼äº std::vector çš„åŠ¨æ€å¢é•¿
	 * - ä¹Ÿå¯ä»¥é‡‡ç”¨å€å¢ç­–ç•¥ï¼ˆå¦‚ *2ï¼‰ä»¥å‡æ‘Š O(1)
	 */
	class Plateau
	{
	private:
		// ====================================================================
		// ç§æœ‰æˆå‘˜å˜é‡ (Private Member Variables)
		// ====================================================================

		/**
		 * cartes: æŒ‡å‘å¡ç‰ŒæŒ‡é’ˆçš„åŠ¨æ€æ•°ç»„
		 *
		 * ç±»å‹ï¼šconst Carte**
		 * - åŠ¨æ€åˆ†é…ï¼Œæ”¯æŒæ‰©å®¹
		 * - å­˜å‚¨æŒ‡å‘ Carte çš„æŒ‡é’ˆï¼ˆèšåˆï¼‰
		 */
		const Carte **cartes;

		/**
		 * nbMax: æ•°ç»„çš„æœ€å¤§å®¹é‡
		 *
		 * è¡¨ç¤ºå½“å‰å·²åˆ†é…çš„æ•°ç»„å¤§å°
		 * å½“ nb è¾¾åˆ° nbMax æ—¶éœ€è¦æ‰©å®¹
		 */
		size_t nbMax;

		/**
		 * nb: å½“å‰æ¡Œé¢ä¸Šçš„å¡ç‰Œæ•°é‡
		 *
		 * è¡¨ç¤ºæ•°ç»„ä¸­å®é™…ä½¿ç”¨çš„å…ƒç´ æ•°é‡
		 * èŒƒå›´ï¼š0 <= nb <= nbMax
		 */
		size_t nb;

	public:
		// ====================================================================
		// æ„é€ å‡½æ•° (Constructor)
		// ====================================================================

		/**
		 * é»˜è®¤æ„é€ å‡½æ•°ï¼šåˆ›å»ºç©ºçš„æ¡Œé¢
		 *
		 * åˆå§‹åŒ–ç­–ç•¥ï¼š
		 * - åˆ†é…åˆå§‹å®¹é‡ï¼ˆ5 ä¸ªä½ç½®ï¼‰
		 * - åˆå§‹æ—¶æ²¡æœ‰å¡ç‰Œï¼ˆnb = 0ï¼‰
		 *
		 * ä¸ºä»€ä¹ˆåˆå§‹å®¹é‡æ˜¯ 5ï¼Ÿ
		 * - é¿å…é¢‘ç¹æ‰©å®¹
		 * - ä¸è¦å¤ªå¤§ï¼ˆæµªè´¹å†…å­˜ï¼‰
		 * - å¯ä»¥é€šè¿‡é…ç½®æ–‡ä»¶è°ƒæ•´
		 */
		Plateau()
		{
			cartes = new const Carte *[5]; // åˆ†é…åˆå§‹æ•°ç»„
			nbMax = 5;					   // è®¾ç½®å®¹é‡
			nb = 0;						   // åˆå§‹ä¸ºç©º
		}

		// ====================================================================
		// ææ„å‡½æ•° (Destructor)
		// ====================================================================

		/**
		 * ææ„å‡½æ•°ï¼šé‡Šæ”¾åŠ¨æ€åˆ†é…çš„æ•°ç»„
		 *
		 * æ³¨æ„ï¼šåªåˆ é™¤æŒ‡é’ˆæ•°ç»„ï¼Œä¸åˆ é™¤ Carte å¯¹è±¡
		 * åŸå› ï¼šèšåˆå…³ç³»ï¼ŒCarte ç”± Jeu ç®¡ç†
		 */
		~Plateau() { delete[] cartes; }

		// ====================================================================
		// å…¬æœ‰æ–¹æ³• (Public Methods)
		// ====================================================================

		/**
		 * getNbCartes: è·å–æ¡Œé¢ä¸Šçš„å¡ç‰Œæ•°é‡
		 */
		size_t getNbCartes() const { return nb; }

		/**
		 * ajouter: å‘æ¡Œé¢æ·»åŠ ä¸€å¼ å¡ç‰Œ
		 *
		 * å‚æ•°ï¼šc - è¦æ·»åŠ çš„å¡ç‰Œå¼•ç”¨
		 *
		 * ç®—æ³•ï¼š
		 * 1. æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰©å®¹ï¼ˆnb == nbMaxï¼‰
		 * 2. å¦‚æœéœ€è¦ï¼Œåˆ†é…æ›´å¤§çš„æ•°ç»„å¹¶å¤åˆ¶
		 * 3. å°†å¡ç‰ŒæŒ‡é’ˆæ·»åŠ åˆ°æ•°ç»„æœ«å°¾
		 * 4. nb++
		 *
		 * æ‰©å®¹ç­–ç•¥ï¼š
		 * - åˆ›å»ºå¤§å°ä¸º (nbMax + 5) çš„æ–°æ•°ç»„
		 * - å¤åˆ¶æ‰€æœ‰ç°æœ‰æŒ‡é’ˆ
		 * - åˆ é™¤æ—§æ•°ç»„
		 * - æ›´æ–° cartes å’Œ nbMax
		 *
		 * æ—¶é—´å¤æ‚åº¦ï¼š
		 * - ä¸æ‰©å®¹ï¼šO(1)
		 * - æ‰©å®¹ï¼šO(n)
		 *
		 * å®ç°åœ¨ set.cpp ä¸­
		 */
		void ajouter(const Carte &c);

		/**
		 * retirer: ä»æ¡Œé¢ç§»é™¤ä¸€å¼ å¡ç‰Œ
		 *
		 * å‚æ•°ï¼šc - è¦ç§»é™¤çš„å¡ç‰Œå¼•ç”¨
		 *
		 * ç®—æ³•ï¼š
		 * 1. éå†æ•°ç»„æŸ¥æ‰¾å¡ç‰Œåœ°å€
		 * 2. å¦‚æœæ‰¾åˆ°ï¼Œç”¨æœ€åä¸€å¼ å¡å¡«è¡¥ç©ºä½
		 * 3. nb--
		 * 4. å¦‚æœæœªæ‰¾åˆ°ï¼ŒæŠ›å‡ºå¼‚å¸¸
		 *
		 * æ—¶é—´å¤æ‚åº¦ï¼šO(n)
		 *
		 * å®ç°åœ¨ set.cpp ä¸­
		 */
		void retirer(const Carte &c);

		/**
		 * æ‹·è´æ„é€ å‡½æ•°ï¼šæ·±æ‹·è´ Plateau
		 *
		 * ä¸ºä»€ä¹ˆéœ€è¦ï¼Ÿ
		 * - é¿å…æµ…æ‹·è´å¯¼è‡´çš„åŒé‡é‡Šæ”¾
		 * - æ¯ä¸ª Plateau éœ€è¦ç‹¬ç«‹çš„æ•°ç»„
		 *
		 * å®ç°ï¼š
		 * 1. åˆ†é…æ–°çš„æ•°ç»„ï¼ˆå¤§å°ä¸º p.nbMaxï¼‰
		 * 2. å¤åˆ¶æ‰€æœ‰å¡ç‰ŒæŒ‡é’ˆ
		 * 3. å¤åˆ¶ nb å’Œ nbMax
		 *
		 * å®ç°åœ¨ set.cpp ä¸­
		 */
		Plateau(const Plateau &p);

		/**
		 * èµ‹å€¼è¿ç®—ç¬¦ï¼šæ·±æ‹·è´èµ‹å€¼
		 *
		 * å¿…é¡»å¤„ç†ï¼š
		 * 1. è‡ªèµ‹å€¼æ£€æŸ¥ï¼ˆif (this != &p)ï¼‰
		 * 2. é‡Šæ”¾å½“å‰èµ„æºæˆ–é‡ç”¨ç°æœ‰æ•°ç»„
		 * 3. å¤åˆ¶æ–°æ•°æ®
		 *
		 * å®ç°ç­–ç•¥ï¼š
		 * - æ¸…ç©ºå½“å‰å†…å®¹ï¼ˆnb = 0ï¼‰
		 * - é€ä¸ªæ·»åŠ æºå¯¹è±¡çš„å¡ç‰Œï¼ˆè°ƒç”¨ ajouterï¼‰
		 * - åˆ©ç”¨ ajouter çš„æ‰©å®¹æœºåˆ¶
		 *
		 * å®ç°åœ¨ set.cpp ä¸­
		 */
		Plateau &operator=(const Plateau &p);

		/**
		 * print: æ‰“å°æ¡Œé¢ä¸Šçš„æ‰€æœ‰å¡ç‰Œ
		 *
		 * å‚æ•°ï¼šf - è¾“å‡ºæµ
		 *
		 * æ ¼å¼ï¼šæ¯è¡Œæ˜¾ç¤ºè‹¥å¹²å¼ å¡ç‰Œï¼Œä¾¿äºé˜…è¯»
		 *
		 * å®ç°åœ¨ set.cpp ä¸­
		 */
		void print(ostream &f) const;

		// ====================================================================
		// Ex23: STL é£æ ¼è¿­ä»£å™¨ (STL-style Iterator)
		// ====================================================================

		/**
		 * const_iterator: ç¬¦åˆ C++ æ ‡å‡†åº“é£æ ¼çš„è¿­ä»£å™¨
		 *
		 * è®¾è®¡ç›®æ ‡ï¼š
		 * - å…¼å®¹ C++11 çš„ range-based for å¾ªç¯
		 * - éµå¾ª STL å®¹å™¨çš„è¿­ä»£å™¨æ¥å£è§„èŒƒ
		 *
		 * ä½¿ç”¨ç¤ºä¾‹ï¼š
		 *   for(Plateau::const_iterator it = plateau.begin(); it != plateau.end(); ++it)
		 *       std::cout << *it << "\n";
		 *
		 *   // æˆ–ä½¿ç”¨ range-based for
		 *   for(const Carte& c : plateau)
		 *       std::cout << c << "\n";
		 */
		class const_iterator
		{
		private:
			const Plateau &plateau; // Plateau å®ä¾‹çš„ const å¼•ç”¨
			size_t index;			// å½“å‰ç´¢å¼•

			/**
			 * æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–è¿­ä»£å™¨ä½ç½®
			 */
			const_iterator(const Plateau &p, size_t i) : plateau(p), index(i) {}

			friend class Plateau;

		public:
			/**
			 * operator++: å‰ç¼€é€’å¢è¿ç®—ç¬¦
			 *
			 * ç”¨æ³•ï¼š++it
			 * è¿”å›ï¼šå¼•ç”¨æ”¯æŒé“¾å¼æ“ä½œ
			 */
			const_iterator &operator++()
			{
				index++;
				return *this;
			}

			/**
			 * operator!=: ä¸ç­‰äºæ¯”è¾ƒè¿ç®—ç¬¦
			 *
			 * ç”¨é€”ï¼šrange-based for å¾ªç¯åˆ¤æ–­æ˜¯å¦åˆ°è¾¾ end()
			 */
			bool operator!=(const const_iterator &other) const
			{
				return index != other.index;
			}

			/**
			 * operator==: ç­‰äºæ¯”è¾ƒè¿ç®—ç¬¦
			 */
			bool operator==(const const_iterator &other) const
			{
				return index == other.index;
			}

			/**
			 * operator*: è§£å¼•ç”¨è¿ç®—ç¬¦
			 *
			 * ç”¨æ³•ï¼š*it
			 * è¿”å›ï¼šå½“å‰ä½ç½®çš„ Carte å¼•ç”¨
			 */
			const Carte &operator*() const
			{
				if (index >= plateau.nb)
					throw SetException("Iterator out of bounds");
				return *plateau.cartes[index];
			}
		};

		/**
		 * begin: è¿”å›æŒ‡å‘ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨
		 */
		const_iterator begin() const { return const_iterator(*this, 0); }

		/**
		 * end: è¿”å›æŒ‡å‘"æœ€åä¸€ä¸ªå…ƒç´ ä¹‹å"çš„è¿­ä»£å™¨
		 */
		const_iterator end() const { return const_iterator(*this, nb); }

		/**
		 * cbegin: è¿”å› const è¿­ä»£å™¨ï¼ˆC++11 æ ‡å‡†ï¼‰
		 */
		const_iterator cbegin() const { return begin(); }

		/**
		 * cend: è¿”å› const è¿­ä»£å™¨ï¼ˆC++11 æ ‡å‡†ï¼‰
		 */
		const_iterator cend() const { return end(); }
	};

	/**
	 * è¾“å‡ºè¿ç®—ç¬¦é‡è½½ï¼šæ”¯æŒç›´æ¥è¾“å‡º Plateau å¯¹è±¡
	 * ä½¿ç”¨æ–¹å¼ï¼šcout << plateau << endl;
	 */
	ostream &operator<<(ostream &f, const Plateau &c);

	// ========================================================================
	// Combinaison ç±»ï¼šä¸‰å¡ç»„åˆç±» (Three-Card Combination Class)
	// ========================================================================

	/**
	 * Combinaison: è¡¨ç¤ºç©å®¶é€‰æ‹©çš„ä¸‰å¼ å¡ç‰Œç»„åˆ
	 *
	 * è®¾è®¡è¦ç‚¹ï¼ˆå›ç­”é¢˜ç›®é—®é¢˜10ã€11ï¼‰ï¼š
	 *
	 * é—®é¢˜10ï¼šCarte ä¸ Combinaison çš„å…³ç³»
	 * - èšåˆå…³ç³»ï¼ˆAggregationï¼Œç©ºå¿ƒè±å½¢ï¼‰
	 * - Combinaison æŒæœ‰æŒ‡å‘ Carte çš„æŒ‡é’ˆï¼Œä½†ä¸æ‹¥æœ‰ Carte
	 * - Carte çš„ç”Ÿå‘½å‘¨æœŸç”± Jeu ç®¡ç†
	 * - UMLè¡¨ç¤ºï¼šCombinaison â—‡â€”â€”> Carte (1å¯¹3çš„èšåˆ)
	 *
	 * é—®é¢˜11ï¼šä¸ºä»€ä¹ˆå¯ä»¥ä½¿ç”¨ = defaultï¼Ÿ
	 *
	 * æˆå‘˜å˜é‡åˆ†æï¼š
	 * - c1, c2, c3: ä¸‰ä¸ªæŒ‡é’ˆï¼ˆconst Carte*ï¼‰
	 * - æŒ‡é’ˆæ˜¯åŸºæœ¬ç±»å‹ï¼Œå¯ä»¥å®‰å…¨åœ°æµ…æ‹·è´
	 * - æ²¡æœ‰åŠ¨æ€åˆ†é…çš„èµ„æºéœ€è¦ç®¡ç†
	 *
	 * = default é€‚ç”¨æ¡ä»¶ï¼š
	 * - æ‰€æœ‰æˆå‘˜éƒ½æ˜¯å€¼ç±»å‹æˆ–æŒ‡é’ˆ
	 * - ä¸éœ€è¦æ·±æ‹·è´ï¼ˆæ²¡æœ‰æ‹¥æœ‰çš„èµ„æºï¼‰
	 * - ç¼–è¯‘å™¨ç”Ÿæˆçš„ç‰ˆæœ¬æ»¡è¶³éœ€æ±‚
	 *
	 * å¯¹æ¯” Plateauï¼š
	 * - Plateau æœ‰åŠ¨æ€æ•°ç»„ï¼Œéœ€è¦æ·±æ‹·è´
	 * - Combinaison åªæœ‰ä¸‰ä¸ªæŒ‡é’ˆï¼Œæµ…æ‹·è´å³å¯
	 *
	 * æ ¸å¿ƒåŠŸèƒ½ï¼š
	 * - å­˜å‚¨ä¸‰å¼ å¡ç‰Œçš„å¼•ç”¨
	 * - åˆ¤æ–­è¿™ä¸‰å¼ å¡æ˜¯å¦æ„æˆæœ‰æ•ˆçš„ SET
	 *
	 * SET è§„åˆ™å›é¡¾ï¼š
	 * å¯¹äºæ¯ä¸ªç‰¹å¾ï¼ˆé¢œè‰²ã€æ•°é‡ã€å½¢çŠ¶ã€å¡«å……ï¼‰ï¼š
	 * - è¦ä¹ˆä¸‰å¼ å¡å®Œå…¨ç›¸åŒ
	 * - è¦ä¹ˆä¸‰å¼ å¡å®Œå…¨ä¸åŒ
	 * - ä¸å…è®¸"ä¸¤åŒä¸€å¼‚"çš„æƒ…å†µ
	 */
	class Combinaison
	{
	private:
		// ====================================================================
		// ç§æœ‰æˆå‘˜å˜é‡ (Private Member Variables)
		// ====================================================================

		/**
		 * c1, c2, c3: æŒ‡å‘ä¸‰å¼ å¡ç‰Œçš„æŒ‡é’ˆ
		 *
		 * ç±»å‹ï¼šconst Carte*
		 * - const: ä¸èƒ½é€šè¿‡æŒ‡é’ˆä¿®æ”¹å¡ç‰Œ
		 * - æŒ‡é’ˆ: ä¸æ‹¥æœ‰å¡ç‰Œï¼Œåªæ˜¯å¼•ç”¨
		 *
		 * ä¸ºä»€ä¹ˆä¸ç”¨å¼•ç”¨ï¼ˆconst Carte&ï¼‰ï¼Ÿ
		 * - å¼•ç”¨å¿…é¡»åœ¨æ„é€ æ—¶åˆå§‹åŒ–ï¼Œæ— æ³•é‡æ–°èµ‹å€¼
		 * - æŒ‡é’ˆæ›´çµæ´»ï¼Œæ”¯æŒåç»­ä¿®æ”¹ï¼ˆè™½ç„¶è¿™é‡Œä¸éœ€è¦ï¼‰
		 * - æŒ‡é’ˆå¯ä»¥ä¸º nullptrï¼ˆè™½ç„¶è¿™é‡Œä¸ä¼šï¼‰
		 */
		const Carte *c1;
		const Carte *c2;
		const Carte *c3;

	public:
		// ====================================================================
		// æ„é€ å‡½æ•° (Constructor)
		// ====================================================================

		/**
		 * æ„é€ å‡½æ•°ï¼šä»ä¸‰å¼ å¡ç‰Œåˆ›å»ºç»„åˆ
		 *
		 * å‚æ•°ï¼šC1, C2, C3 - ä¸‰å¼ å¡ç‰Œçš„å¼•ç”¨
		 *
		 * å®ç°ï¼šä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨
		 * - c1(&C1): è·å– C1 çš„åœ°å€å¹¶èµ‹ç»™ c1
		 * - å­˜å‚¨çš„æ˜¯åœ°å€ï¼Œä¸æ˜¯æ‹·è´å¯¹è±¡
		 *
		 * è®¾è®¡é€‰æ‹©ï¼š
		 * - å‚æ•°æ˜¯å¼•ç”¨ï¼šé¿å…ä¸å¿…è¦çš„æ‹·è´
		 * - æˆå‘˜æ˜¯æŒ‡é’ˆï¼šæ”¯æŒåç»­å¯èƒ½çš„ä¿®æ”¹
		 */
		Combinaison(const Carte &C1, const Carte &C2, const Carte &C3)
			: c1(&C1), c2(&C2), c3(&C3) {}

		// ====================================================================
		// è®¿é—®å™¨æ–¹æ³• (Accessor Methods)
		// ====================================================================

		/**
		 * getCarte ç³»åˆ—ï¼šè·å–å„å¼ å¡ç‰Œçš„å¼•ç”¨
		 *
		 * è¿”å›ï¼š*c1 è§£å¼•ç”¨æŒ‡é’ˆå¾—åˆ° Carte å¯¹è±¡
		 */
		const Carte &getCarte1() const { return *c1; }
		const Carte &getCarte2() const { return *c2; }
		const Carte &getCarte3() const { return *c3; }

		/**
		 * estUnSet: åˆ¤æ–­è¿™ä¸‰å¼ å¡æ˜¯å¦æ„æˆæœ‰æ•ˆçš„ SET
		 *
		 * è§„åˆ™ï¼šå¯¹äºæ¯ä¸ªç‰¹å¾ï¼ˆé¢œè‰²ã€å½¢çŠ¶ã€æ•°é‡ã€å¡«å……ï¼‰
		 * - è¦ä¹ˆä¸‰ä¸ªå®Œå…¨ç›¸åŒ
		 * - è¦ä¹ˆä¸‰ä¸ªå®Œå…¨ä¸åŒ
		 *
		 * æ•°å­¦è¡¨è¾¾ï¼š
		 * å¯¹äºç‰¹å¾ Xï¼š
		 * - å…¨åŒï¼šX1 == X2 && X1 == X3
		 * - å…¨å¼‚ï¼šX1 != X2 && X1 != X3 && X2 != X3
		 *
		 * å®ç°ç®—æ³•ï¼š
		 * 1. å¯¹å››ä¸ªç‰¹å¾åˆ†åˆ«æ£€æŸ¥
		 * 2. æ¯ä¸ªç‰¹å¾è¿”å› true/false
		 * 3. å››ä¸ªç»“æœè¿›è¡Œ AND è¿ç®—
		 *
		 * æ—¶é—´å¤æ‚åº¦ï¼šO(1)ï¼ˆå›ºå®šçš„4ä¸ªç‰¹å¾æ£€æŸ¥ï¼‰
		 *
		 * å®ç°åœ¨ set.cpp ä¸­
		 */
		bool estUnSet() const;

		// ====================================================================
		// ç‰¹æ®Šæˆå‘˜å‡½æ•° (Special Member Functions)
		// ====================================================================

		/**
		 * ææ„å‡½æ•°ï¼šä½¿ç”¨é»˜è®¤å®ç°
		 *
		 * ä¸ºä»€ä¹ˆ = default è¶³å¤Ÿï¼Ÿ
		 * - åªæœ‰ä¸‰ä¸ªæŒ‡é’ˆæˆå‘˜
		 * - ä¸æ‹¥æœ‰ä»»ä½•éœ€è¦æ‰‹åŠ¨é‡Šæ”¾çš„èµ„æº
		 * - æŒ‡é’ˆæŒ‡å‘çš„ Carte ç”± Jeu ç®¡ç†
		 */
		~Combinaison() = default;

		/**
		 * æ‹·è´æ„é€ å‡½æ•°ï¼šä½¿ç”¨é»˜è®¤å®ç°
		 *
		 * é»˜è®¤è¡Œä¸ºï¼šé€æˆå‘˜æ‹·è´ï¼ˆæµ…æ‹·è´ï¼‰
		 * - c1, c2, c3 æ˜¯æŒ‡é’ˆï¼Œæ‹·è´æŒ‡é’ˆå€¼
		 * - ä¸¤ä¸ª Combinaison ä¼šæŒ‡å‘ç›¸åŒçš„ Carte
		 * - è¿™æ˜¯åˆç†çš„ï¼Œå› ä¸ºä¸æ‹¥æœ‰ Carte
		 */
		Combinaison(const Combinaison &c) = default;

		/**
		 * èµ‹å€¼è¿ç®—ç¬¦ï¼šä½¿ç”¨é»˜è®¤å®ç°
		 *
		 * é»˜è®¤è¡Œä¸ºï¼šé€æˆå‘˜èµ‹å€¼
		 * å¯¹äº Combinaison æ¥è¯´å·²ç»è¶³å¤Ÿ
		 */
		Combinaison &operator=(const Combinaison &c) = default;
	};

	/**
	 * è¾“å‡ºè¿ç®—ç¬¦é‡è½½ï¼šæ ¼å¼åŒ–è¾“å‡ºç»„åˆ
	 * æ ¼å¼ï¼š[å¡1 ; å¡2 ; å¡3]
	 */
	ostream &operator<<(ostream &f, const Combinaison &c);

	// ========================================================================
	// Controleur ç±»ï¼šæ¸¸æˆæ§åˆ¶å™¨ç±» (Game Controller Class)
	// ========================================================================

	/**
	 * Controleur: æ¸¸æˆæ§åˆ¶å™¨ï¼Œç®¡ç†æ¸¸æˆæµç¨‹
	 *
	 * è®¾è®¡è¦ç‚¹ï¼ˆå›ç­”é¢˜ç›®é—®é¢˜12ã€13ï¼‰ï¼š
	 *
	 * é—®é¢˜12ï¼šControleur ä¸å…¶ä»–ç±»çš„å…³ç³»
	 *
	 * 1. Controleur â€”â€”> Jeu: å…³è”å…³ç³»ï¼ˆå¼•ç”¨ï¼‰
	 *    - jeu æ˜¯å¼•ç”¨æˆå‘˜ï¼ŒæŒ‡å‘å•ä¾‹
	 *    - ä¸æ‹¥æœ‰ Jeuï¼ŒJeu æ˜¯å…¨å±€å•ä¾‹
	 *    - UML: Controleur -----> Jeu
	 *
	 * 2. Controleur â—†â€”â€”> Plateau: ç»„åˆå…³ç³»
	 *    - plateau æ˜¯å€¼æˆå‘˜ï¼ˆä¸æ˜¯æŒ‡é’ˆï¼‰
	 *    - Controleur æ‹¥æœ‰å¹¶ç®¡ç† Plateau çš„ç”Ÿå‘½å‘¨æœŸ
	 *    - Plateau éš Controleur åˆ›å»ºå’Œé”€æ¯
	 *    - UML: Controleur â—†â€”â€”> Plateau
	 *
	 * 3. Controleur â—†â€”â€”> Pioche: ç»„åˆå…³ç³»
	 *    - pioche æ˜¯æŒ‡é’ˆï¼ŒæŒ‡å‘åŠ¨æ€åˆ†é…çš„å¯¹è±¡
	 *    - Controleur è´Ÿè´£ Pioche çš„åˆ›å»ºï¼ˆnewï¼‰å’Œé”€æ¯ï¼ˆdeleteï¼‰
	 *    - Pioche çš„ç”Ÿå‘½å‘¨æœŸå®Œå…¨ç”± Controleur ç®¡ç†
	 *    - UML: Controleur â—†â€”â€”> Pioche
	 *
	 * ä¸ºä»€ä¹ˆ Plateau æ˜¯å€¼ï¼ŒPioche æ˜¯æŒ‡é’ˆï¼Ÿ
	 * - Plateau: å¯ä»¥åœ¨æ ˆä¸Šåˆ›å»ºï¼Œæ„é€ ç®€å•ï¼Œæ— éœ€æŒ‡é’ˆ
	 * - Pioche: éœ€è¦ Jeu å¼•ç”¨æ¥åˆå§‹åŒ–ï¼Œæ„é€ å‡½æ•°è°ƒç”¨åœ¨ Controleur
	 *          æ„é€ å‡½æ•°ä½“å†…ï¼Œå¿…é¡»ç”¨æŒ‡é’ˆ
	 *
	 * é—®é¢˜13ï¼šä¸ºä»€ä¹ˆç¦æ­¢æ‹·è´ï¼Ÿ
	 * - èµ„æºç®¡ç†ï¼špioche æ˜¯åŠ¨æ€åˆ†é…çš„ï¼Œæ‹·è´ä¼šå¯¼è‡´é—®é¢˜
	 * - è¯­ä¹‰ä¸æ˜ï¼šå¤åˆ¶æ¸¸æˆæ§åˆ¶å™¨çš„å«ä¹‰ä¸æ¸…
	 * - å•ä¸€æ§åˆ¶ï¼šä¸€ä¸ªæ¸¸æˆåº”è¯¥åªæœ‰ä¸€ä¸ªæ§åˆ¶å™¨
	 *
	 * èŒè´£è¯´æ˜ï¼š
	 * - åˆå§‹åŒ–æ¸¸æˆï¼ˆåˆ›å»ºç‰Œå †ã€æ¡Œé¢ï¼‰
	 * - ç®¡ç†æ¸¸æˆæµç¨‹ï¼ˆå‘ç‰Œç­‰ï¼‰
	 * - æä¾›è®¿é—®æ¸¸æˆçŠ¶æ€çš„æ¥å£
	 */
	class Controleur
	{
	private:
		// ====================================================================
		// ç§æœ‰æˆå‘˜å˜é‡ (Private Member Variables)
		// ====================================================================

		/**
		 * jeu: Jeu å•ä¾‹çš„å¼•ç”¨
		 *
		 * ç±»å‹ï¼šJeu& ï¼ˆå¼•ç”¨ï¼‰
		 * - å¿…é¡»åœ¨åˆå§‹åŒ–åˆ—è¡¨ä¸­åˆå§‹åŒ–
		 * - å¼•ç”¨ä¸€æ—¦ç»‘å®šå°±ä¸èƒ½æ”¹å˜
		 * - æŒ‡å‘å…¨å±€å”¯ä¸€çš„ Jeu å®ä¾‹
		 *
		 * å…³ç³»ç±»å‹ï¼šå…³è”ï¼ˆAssociationï¼‰
		 * - Controleur ä½¿ç”¨ Jeuï¼Œä½†ä¸æ‹¥æœ‰å®ƒ
		 * - Jeu çš„ç”Ÿå‘½å‘¨æœŸç‹¬ç«‹äº Controleur
		 */
		Jeu &jeu;

		/**
		 * plateau: æ¸¸æˆæ¡Œé¢å¯¹è±¡
		 *
		 * ç±»å‹ï¼šPlateau ï¼ˆå€¼æˆå‘˜ï¼‰
		 * - ä¸æ˜¯æŒ‡é’ˆï¼Œç›´æ¥åµŒå…¥åœ¨ Controleur ä¸­
		 * - éš Controleur è‡ªåŠ¨åˆ›å»ºå’Œé”€æ¯
		 * - ä½¿ç”¨ Plateau çš„é»˜è®¤æ„é€ å‡½æ•°åˆå§‹åŒ–
		 *
		 * å…³ç³»ç±»å‹ï¼šç»„åˆï¼ˆCompositionï¼‰
		 * - Controleur æ‹¥æœ‰ Plateau
		 * - Plateau çš„ç”Ÿå‘½å‘¨æœŸä¸ Controleur ç›¸åŒ
		 * - Plateau ä¸èƒ½ç‹¬ç«‹äº Controleur å­˜åœ¨
		 */
		Plateau plateau;

		/**
		 * pioche: ç‰Œå †å¯¹è±¡çš„æŒ‡é’ˆ
		 *
		 * ç±»å‹ï¼šPioche* ï¼ˆæŒ‡é’ˆï¼‰
		 * - æŒ‡å‘åŠ¨æ€åˆ†é…çš„ Pioche å¯¹è±¡
		 * - åœ¨æ„é€ å‡½æ•°ä½“å†…åˆ›å»ºï¼ˆnew Pioche(jeu)ï¼‰
		 * - åœ¨ææ„å‡½æ•°ä¸­é”€æ¯ï¼ˆdelete piocheï¼‰
		 *
		 * ä¸ºä»€ä¹ˆæ˜¯æŒ‡é’ˆè€Œä¸æ˜¯å€¼ï¼Ÿ
		 * 1. Pioche æ„é€ å‡½æ•°éœ€è¦ jeu å‚æ•°
		 * 2. jeu åœ¨åˆå§‹åŒ–åˆ—è¡¨ä¸­æ‰èƒ½è·å–
		 * 3. plateau å¯ä»¥é»˜è®¤æ„é€ ï¼Œæ‰€ä»¥å¯ä»¥æ˜¯å€¼
		 * 4. pioche éœ€è¦å‚æ•°ï¼Œå¿…é¡»åœ¨æ„é€ å‡½æ•°ä½“å†… new
		 *
		 * å…³ç³»ç±»å‹ï¼šç»„åˆï¼ˆCompositionï¼‰
		 * - Controleur æ‹¥æœ‰å¹¶ç®¡ç† Pioche
		 * - Controleur è´Ÿè´£åˆ›å»ºå’Œé”€æ¯ Pioche
		 * - Pioche çš„ç”Ÿå‘½å‘¨æœŸç”± Controleur æ§åˆ¶
		 */
		Pioche *pioche;

	public:
		// ====================================================================
		// æ„é€ å‡½æ•° (Constructor)
		// ====================================================================

		/**
		 * æ„é€ å‡½æ•°ï¼šåˆå§‹åŒ–æ¸¸æˆæ§åˆ¶å™¨
		 *
		 * åˆå§‹åŒ–é¡ºåºï¼š
		 * 1. åˆå§‹åŒ–åˆ—è¡¨ï¼šjeu(Jeu::getInstance())
		 *    - è·å– Jeu å•ä¾‹çš„å¼•ç”¨
		 *    - å¿…é¡»åœ¨æ­¤å¤„åˆå§‹åŒ–ï¼ˆå¼•ç”¨æˆå‘˜çš„è¦æ±‚ï¼‰
		 *
		 * 2. éšå¼è°ƒç”¨ï¼šplateau çš„é»˜è®¤æ„é€ å‡½æ•°
		 *    - Plateau() ä¼šè‡ªåŠ¨è°ƒç”¨
		 *    - åˆ›å»ºç©ºçš„æ¡Œé¢
		 *
		 * 3. æ„é€ å‡½æ•°ä½“ï¼špioche = new Pioche(jeu)
		 *    - åŠ¨æ€åˆ†é… Pioche å¯¹è±¡
		 *    - ä¼ å…¥ jeu å¼•ç”¨åˆå§‹åŒ–ç‰Œå †
		 *
		 * ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ
		 * - jeu å¿…é¡»å…ˆåˆå§‹åŒ–ï¼ˆå¼•ç”¨çš„è¦æ±‚ï¼‰
		 * - pioche ä¾èµ– jeuï¼ˆéœ€è¦ jeu ä½œä¸ºå‚æ•°ï¼‰
		 * - plateau ç‹¬ç«‹ï¼Œå¯ä»¥è‡ªåŠ¨åˆå§‹åŒ–
		 *
		 * å†…å­˜å¸ƒå±€ï¼š
		 * - jeu: å¼•ç”¨ï¼ˆ8å­—èŠ‚ï¼Œ64ä½ç³»ç»Ÿï¼‰
		 * - plateau: Plateau å¯¹è±¡ï¼ˆç›´æ¥åµŒå…¥ï¼‰
		 * - pioche: æŒ‡é’ˆï¼ˆ8å­—èŠ‚ï¼Œ64ä½ç³»ç»Ÿï¼‰
		 */
		Controleur() : jeu(Jeu::getInstance())
		{
			pioche = new Pioche(jeu); // åŠ¨æ€åˆ›å»ºç‰Œå †
		}

		// ====================================================================
		// è®¿é—®å™¨æ–¹æ³• (Accessor Methods)
		// ====================================================================

		/**
		 * getPlateau: è·å–æ¡Œé¢çš„å¸¸é‡å¼•ç”¨
		 *
		 * è¿”å›ï¼šconst Plateau&
		 * - é¿å…æ‹·è´
		 * - ä¿æŠ¤æ¡Œé¢ä¸è¢«å¤–éƒ¨ä¿®æ”¹ï¼ˆconstï¼‰
		 */
		const Plateau &getPlateau() const { return plateau; }

		/**
		 * getPioche: è·å–ç‰Œå †çš„å¸¸é‡å¼•ç”¨
		 *
		 * è¿”å›ï¼šconst Pioche&
		 * - *pioche è§£å¼•ç”¨æŒ‡é’ˆå¾—åˆ°å¯¹è±¡
		 * - è¿”å›å¼•ç”¨é¿å…æ‹·è´
		 */
		const Pioche &getPioche() const { return *pioche; }

		// ====================================================================
		// æ¸¸æˆé€»è¾‘æ–¹æ³• (Game Logic Methods)
		// ====================================================================

		/**
		 * distribuer: å°†ç‰Œå †ä¸­çš„å¡ç‰Œå‘åˆ°æ¡Œé¢
		 *
		 * æ¸¸æˆè§„åˆ™ï¼š
		 * - å¦‚æœæ¡Œé¢å¡ç‰Œæ•° < 12ï¼šè¡¥åˆ° 12 å¼ 
		 * - å¦‚æœæ¡Œé¢å¡ç‰Œæ•° >= 12ï¼šåªåŠ  1 å¼ 
		 * - å¦‚æœç‰Œå †ä¸ºç©ºï¼šä¸åšä»»ä½•æ“ä½œ
		 *
		 * ç®—æ³•ï¼š
		 * 1. æ£€æŸ¥ç‰Œå †æ˜¯å¦ä¸ºç©º
		 * 2. å¦‚æœæ¡Œé¢ < 12ï¼Œå¾ªç¯æŠ½ç‰Œç›´åˆ°è¾¾åˆ° 12 æˆ–ç‰Œå †ç©º
		 * 3. å¦åˆ™ï¼ŒåªæŠ½ä¸€å¼ ç‰Œ
		 *
		 * å®ç°åœ¨ set.cpp ä¸­
		 */
		void distribuer();

		// ====================================================================
		// ææ„å‡½æ•° (Destructor)
		// ====================================================================

		/**
		 * ææ„å‡½æ•°ï¼šæ¸…ç†èµ„æº
		 *
		 * å¿…é¡»åšçš„äº‹ï¼š
		 * - delete pioche: é‡Šæ”¾åŠ¨æ€åˆ†é…çš„ Pioche å¯¹è±¡
		 *
		 * è‡ªåŠ¨å®Œæˆçš„äº‹ï¼š
		 * - plateau çš„ææ„å‡½æ•°è‡ªåŠ¨è°ƒç”¨ï¼ˆå€¼æˆå‘˜ï¼‰
		 * - jeu æ˜¯å¼•ç”¨ï¼Œä¸éœ€è¦é”€æ¯
		 *
		 * ä¸‰äº”æ³•åˆ™ï¼ˆRule of Three/Fiveï¼‰ï¼š
		 * - å¦‚æœéœ€è¦è‡ªå®šä¹‰ææ„å‡½æ•°ï¼ˆå› ä¸º piocheï¼‰
		 * - é€šå¸¸ä¹Ÿéœ€è¦è‡ªå®šä¹‰æ‹·è´æ„é€ å’Œèµ‹å€¼è¿ç®—ç¬¦
		 * - è¿™é‡Œé€‰æ‹©ç¦ç”¨æ‹·è´å’Œèµ‹å€¼ï¼ˆ= deleteï¼‰
		 */
		~Controleur() { delete pioche; }

		// ====================================================================
		// ç¦ç”¨æ‹·è´å’Œèµ‹å€¼ (Deleted Copy and Assignment)
		// ====================================================================

		/**
		 * æ‹·è´æ„é€ å‡½æ•°ï¼šå·²åˆ é™¤
		 *
		 * ä¸ºä»€ä¹ˆç¦æ­¢ï¼Ÿ
		 * 1. pioche æ˜¯æŒ‡é’ˆï¼Œæµ…æ‹·è´ä¼šå¯¼è‡´ä¸¤ä¸ªå¯¹è±¡å…±äº«åŒä¸€ä¸ª Pioche
		 * 2. ææ„æ—¶ä¼šåŒé‡é‡Šæ”¾ï¼ˆdouble freeï¼‰
		 * 3. jeu æ˜¯å¼•ç”¨ï¼Œæ‹·è´åä»æŒ‡å‘åŒä¸€ä¸ª Jeuï¼ˆå¯èƒ½ä¸æ˜¯é—®é¢˜ï¼‰
		 * 4. plateau å¯ä»¥æ‹·è´ï¼Œä½†æ•´ä½“è¯­ä¹‰ä¸æ˜ç¡®
		 * 5. æ¸¸æˆæ§åˆ¶å™¨åº”è¯¥å”¯ä¸€ï¼Œä¸åº”è¯¥å¤åˆ¶
		 */
		Controleur(const Controleur &c) = delete;

		/**
		 * èµ‹å€¼è¿ç®—ç¬¦ï¼šå·²åˆ é™¤
		 * åŸå› åŒä¸Š
		 */
		Controleur &operator=(const Controleur &c) = delete;
	};

}; // end of namespace Set

#endif // _SET_H
```

## main.cpp
```cpp
#include "set.h"
#include <vector>
#include <algorithm>
using namespace Set;

void f(Plateau &dest, const Plateau &source)
{
	dest = source;
}

// ============================================================================
// Ex23 åŠŸèƒ½å‡½æ•° (Ex23 Functions)
// ============================================================================

/**
 * é¢˜ç›® 4ï¼šä½¿ç”¨ä¼ ç»Ÿè¿­ä»£å™¨éå†æ‰€æœ‰å¡ç‰Œ
 */
void afficherCartes()
{
	Jeu &jeu = Jeu::getInstance();
	cout << "\n=== ä½¿ç”¨ Iterator éå†æ‰€æœ‰å¡ç‰Œ ===" << endl;
	int count = 0;
	for (Jeu::Iterator it = jeu.first(); !it.isDone(); it.next())
	{
		cout << it.getCurrentItem() << " ";
		if (++count % 9 == 0)
			cout << "\n";
	}
	cout << "\næ€»å…± " << count << " å¼ å¡ç‰Œ\n"
		 << endl;
}

/**
 * é¢˜ç›® 5ï¼šä½¿ç”¨å½¢çŠ¶è¿‡æ»¤è¿­ä»£å™¨éå†ç‰¹å®šå½¢çŠ¶çš„å¡ç‰Œ
 */
void afficherCartes(Forme f)
{
	Jeu &jeu = Jeu::getInstance();
	cout << "\n=== ä½¿ç”¨ FormeIterator éå†å½¢çŠ¶ä¸º " << f << " çš„å¡ç‰Œ ===" << endl;

	// éœ€è¦å…ˆæ‰¾åˆ°ç¬¬ä¸€å¼ åŒ¹é…çš„å¡ç‰Œ
	Jeu::FormeIterator it = jeu.firstFormeIterator(f);

	// æ‰¾åˆ°ç¬¬ä¸€å¼ åŒ¹é…çš„å¡ç‰Œ
	while (!it.isDone() && it.getCurrentItem().getForme() != f)
		it.next();

	int count = 0;
	while (!it.isDone())
	{
		cout << it.getCurrentItem() << " ";
		if (++count % 9 == 0)
			cout << "\n";
		it.next();
	}
	cout << "\næ€»å…± " << count << " å¼  " << f << " å½¢çŠ¶çš„å¡ç‰Œ\n"
		 << endl;
}

/**
 * é¢˜ç›® 6ï¼šä½¿ç”¨ STL é£æ ¼è¿­ä»£å™¨éå† Plateau
 */
void afficherCartes(const Plateau &p)
{
	cout << "\n=== ä½¿ç”¨ STL é£æ ¼è¿­ä»£å™¨éå† Plateau ===" << endl;
	int count = 0;
	for (Plateau::const_iterator it = p.begin(); it != p.end(); ++it)
	{
		cout << *it << " ";
		if (++count % 6 == 0)
			cout << "\n";
	}
	cout << "\næ€»å…± " << count << " å¼ å¡ç‰Œåœ¨ Plateau ä¸Š\n"
		 << endl;
}

/**
 * æŸ¥æ‰¾ Plateau ä¸­æ‰€æœ‰æœ‰æ•ˆçš„ SET ç»„åˆ
 */
std::vector<Combinaison> trouverTousSets(const Plateau &p)
{
	std::vector<Combinaison> sets;
	size_t n = p.getNbCartes();

	// ä½¿ç”¨è¿­ä»£å™¨éå†æ‰€æœ‰ä¸‰å¼ å¡çš„ç»„åˆ
	std::vector<const Carte *> cartes;
	for (Plateau::const_iterator it = p.begin(); it != p.end(); ++it)
	{
		cartes.push_back(&(*it));
	}

	// ä¸‰é‡å¾ªç¯æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„ä¸‰å¼ å¡ç»„åˆ
	for (size_t i = 0; i < n; i++)
	{
		for (size_t j = i + 1; j < n; j++)
		{
			for (size_t k = j + 1; k < n; k++)
			{
				Combinaison combo(*cartes[i], *cartes[j], *cartes[k]);
				if (combo.estUnSet())
				{
					sets.push_back(combo);
				}
			}
		}
	}

	return sets;
}

/**
 * é¢˜ç›® 7ï¼šå®Œæ•´çš„ SET æ¸¸æˆ
 */
void jouerSet()
{
	cout << "\n";
	cout << "========================================" << endl;
	cout << "       æ¬¢è¿æ¥åˆ° SET çº¸ç‰Œæ¸¸æˆï¼         " << endl;
	cout << "========================================" << endl;
	cout << "\nSET è§„åˆ™ï¼š" << endl;
	cout << "æ‰¾å‡ºä¸‰å¼ å¡ç‰Œï¼Œå¯¹äºæ¯ä¸ªç‰¹å¾ï¼ˆé¢œè‰²ã€å½¢çŠ¶ã€æ•°é‡ã€å¡«å……ï¼‰" << endl;
	cout << "è¿™ä¸‰å¼ å¡å¿…é¡»å…¨ç›¸åŒæˆ–å…¨ä¸åŒ\n"
		 << endl;

	Controleur ctrl;
	ctrl.distribuer();

	cout << "å½“å‰æ¡Œé¢ï¼š" << endl;
	cout << ctrl.getPlateau() << endl;

	// è‡ªåŠ¨æŸ¥æ‰¾æ‰€æœ‰ SET
	cout << "æ­£åœ¨æŸ¥æ‰¾æ‰€æœ‰å¯èƒ½çš„ SET ç»„åˆ..." << endl;
	std::vector<Combinaison> sets = trouverTousSets(ctrl.getPlateau());

	if (sets.empty())
	{
		cout << "âŒ å½“å‰æ¡Œé¢ä¸Šæ²¡æœ‰æœ‰æ•ˆçš„ SET ç»„åˆï¼" << endl;
		cout << "éœ€è¦ä»ç‰Œå †å†å‘ç‰Œ..." << endl;
	}
	else
	{
		cout << "âœ“ æ‰¾åˆ° " << sets.size() << " ä¸ªæœ‰æ•ˆçš„ SET ç»„åˆï¼š\n"
			 << endl;
		for (size_t i = 0; i < sets.size(); i++)
		{
			cout << "SET #" << (i + 1) << ": " << sets[i] << endl;
		}
	}

	cout << "\nå‰©ä½™ç‰Œå †å¡ç‰Œæ•°: " << ctrl.getPioche().getNbCartes() << endl;
}

int main()
{
	try
	{
		// Test 1: Display all possible values
		cout << "=== Test 1: Display characteristic values ===" << endl;
		printCouleurs();
		printNombres();
		printFormes();
		printRemplissages();
		cout << endl;

		// Test 2: Get Jeu instance and display some cards
		cout << "=== Test 2: Display some cards from Jeu ===" << endl;
		Jeu &j = Jeu::getInstance();
		for (size_t i = 0; i < 10; i++)
			cout << j.getCarte(i) << "\n";
		cout << endl;

		// Test 3: Use Iterator
		cout << "=== Test 3: Iterate using Iterator ===" << endl;
		Jeu::Iterator it = j.first();
		int count = 0;
		while (!it.isDone() && count < 10)
		{
			cout << it.getCurrentItem();
			it.next();
			count++;
		}
		cout << "\n"
			 << endl;

		// Test 4: Use const_iterator with range-based for loop
		cout << "=== Test 4: Range-based for loop ===" << endl;
		count = 0;
		for (const Carte &c : j)
		{
			cout << c << "\n";
			if (++count >= 10)
				break;
		}
		cout << endl;

		// Test 5: Test Plateau operations
		cout << "=== Test 5: Plateau operations ===" << endl;
		Plateau p1;
		p1.ajouter(j.getCarte(0));
		p1.ajouter(j.getCarte(1));
		p1.ajouter(j.getCarte(2));
		cout << "Plateau p1:" << endl;
		cout << p1;

		Plateau p2;
		p2.ajouter(j.getCarte(3));
		p2.ajouter(j.getCarte(4));
		cout << "Plateau p2:" << endl;
		cout << p2;

		// Test copy constructor
		Plateau p3(p1);
		cout << "Plateau p3 (copy of p1):" << endl;
		cout << p3;

		// Test assignment operator
		p2 = p1;
		cout << "Plateau p2 after p2 = p1:" << endl;
		cout << p2;
		cout << endl;

		// Test 6: Combinaison and estUnSet
		cout << "=== Test 6: Test Combinaison ===" << endl;
		Combinaison combo1(j.getCarte(0), j.getCarte(1), j.getCarte(2));
		cout << "Combinaison: " << combo1 << endl;
		cout << "Est un SET? " << (combo1.estUnSet() ? "Oui" : "Non") << endl;
		cout << endl;

		// Test 7: Controleur
		cout << "=== Test 7: Test Controleur ===" << endl;
		Controleur ctrl;
		ctrl.distribuer();
		cout << ctrl.getPlateau();
		cout << "Nombre de cartes dans la pioche: " << ctrl.getPioche().getNbCartes() << endl;
		cout << endl;

		// ====================================================================
		// Ex23 æµ‹è¯•ï¼šå•ä¾‹æ¨¡å¼å’Œè¿­ä»£å™¨æ¨¡å¼
		// ====================================================================
		cout << "\n";
		cout << "============================================================" << endl;
		cout << "               Ex23: å•ä¾‹æ¨¡å¼ä¸è¿­ä»£å™¨æ¨¡å¼æµ‹è¯•               " << endl;
		cout << "============================================================" << endl;

		// é¢˜ç›® 1-3: å•ä¾‹æ¨¡å¼æµ‹è¯•
		cout << "\n=== é¢˜ç›® 1-3: å•ä¾‹æ¨¡å¼æµ‹è¯• ===" << endl;
		Jeu &jeu1 = Jeu::getInstance();
		Jeu &jeu2 = Jeu::getInstance();
		cout << "Jeu å•ä¾‹æµ‹è¯•ï¼š" << endl;
		cout << "  jeu1 åœ°å€: " << &jeu1 << endl;
		cout << "  jeu2 åœ°å€: " << &jeu2 << endl;
		cout << "  æ˜¯å¦ä¸ºåŒä¸€å®ä¾‹: " << (&jeu1 == &jeu2 ? "æ˜¯ âœ“" : "å¦ âœ—") << endl;
		cout << "  æ€»å¡ç‰Œæ•°: " << jeu1.getNbCartes() << endl;

		// é¢˜ç›® 4: ä¼ ç»Ÿè¿­ä»£å™¨
		afficherCartes();

		// é¢˜ç›® 5: å½¢çŠ¶è¿‡æ»¤è¿­ä»£å™¨
		afficherCartes(Forme::ovale);
		afficherCartes(Forme::vague);
		afficherCartes(Forme::losange);

		// é¢˜ç›® 6: STL é£æ ¼è¿­ä»£å™¨ - Jeu
		cout << "\n=== STL é£æ ¼è¿­ä»£å™¨éå† Jeuï¼ˆå‰ 20 å¼ ï¼‰===" << endl;
		int count2 = 0;
		for (const Carte &c : Jeu::getInstance())
		{
			cout << c << " ";
			if (++count2 >= 20)
				break;
			if (count2 % 10 == 0)
				cout << "\n";
		}
		cout << "\n"
			 << endl;

		// é¢˜ç›® 6: STL é£æ ¼è¿­ä»£å™¨ - Plateau
		Plateau testPlateau;
		Jeu &jeu = Jeu::getInstance();
		for (size_t i = 0; i < 12; i++)
		{
			testPlateau.ajouter(jeu.getCarte(i));
		}
		afficherCartes(testPlateau);

		// ä½¿ç”¨ range-based for éå† Plateau
		cout << "\n=== ä½¿ç”¨ range-based for éå† Plateau ===" << endl;
		int count3 = 0;
		for (const Carte &c : testPlateau)
		{
			cout << c << " ";
			if (++count3 % 6 == 0)
				cout << "\n";
		}
		cout << "\n"
			 << endl;

		// é¢˜ç›® 7: å®Œæ•´çš„ SET æ¸¸æˆ
		cout << "\n";
		cout << "============================================================" << endl;
		cout << "                  é¢˜ç›® 7: å®Œæ•´çš„ SET æ¸¸æˆ                   " << endl;
		cout << "============================================================" << endl;
		jouerSet();

		// é¢å¤–æµ‹è¯•ï¼šå¤šæ¬¡å‘ç‰Œç›´åˆ°æ‰¾åˆ° SET
		cout << "\n\n=== é¢å¤–æµ‹è¯•ï¼šå¤šæ¬¡å°è¯•æ‰¾åˆ° SET ===" << endl;
		Controleur ctrl2;
		int attempts = 0;
		const int maxAttempts = 5;

		while (attempts < maxAttempts)
		{
			attempts++;
			ctrl2.distribuer();

			cout << "\nç¬¬ " << attempts << " æ¬¡å°è¯•ï¼š" << endl;
			cout << "æ¡Œé¢å¡ç‰Œæ•°: " << ctrl2.getPlateau().getNbCartes() << endl;

			std::vector<Combinaison> foundSets = trouverTousSets(ctrl2.getPlateau());

			if (!foundSets.empty())
			{
				cout << "âœ“ æ‰¾åˆ° " << foundSets.size() << " ä¸ª SETï¼" << endl;
				cout << "æ˜¾ç¤ºç¬¬ä¸€ä¸ª SET: " << foundSets[0] << endl;
				break;
			}
			else
			{
				cout << "âœ— æœªæ‰¾åˆ° SETï¼Œç»§ç»­å‘ç‰Œ..." << endl;
			}

			if (ctrl2.getPioche().getNbCartes() == 0)
			{
				cout << "ç‰Œå †å·²ç©ºï¼Œæ¸¸æˆç»“æŸã€‚" << endl;
				break;
			}
		}

		cout << "\n";
		cout << "============================================================" << endl;
		cout << "                    Ex23 æµ‹è¯•å®Œæˆï¼                         " << endl;
		cout << "============================================================" << endl;
	}
	catch (SetException &e)
	{
		std::cout << "Exception: " << e.getInfo() << "\n";
	}

	return 0;
}
```

## set.cpp
```cpp
/**
 * ============================================================================
 * SET æ¸¸æˆå®ç°æ–‡ä»¶ (SET Game Implementation)
 * ============================================================================
 *
 * æœ¬æ–‡ä»¶åŒ…å« set.h ä¸­å£°æ˜çš„æ‰€æœ‰ç±»å’Œå‡½æ•°çš„å®ç°ã€‚
 *
 * ä¸»è¦å†…å®¹ï¼š
 * 1. æšä¸¾å€¼åˆ—è¡¨çš„å®šä¹‰
 * 2. æšä¸¾ç±»å‹çš„è½¬æ¢å’Œè¾“å‡ºå‡½æ•°
 * 3. Carteã€Jeuã€Piocheã€Plateau ç­‰ç±»çš„æ–¹æ³•å®ç°
 * 4. SET åˆ¤æ–­é€»è¾‘çš„å®ç°
 */

#include "set.h"
#include <cstdlib> // æä¾› rand() å‡½æ•°ç”¨äºéšæœºæŠ½ç‰Œ

namespace Set
{
	// ========================================================================
	// å…¨å±€å¸¸é‡åˆ—è¡¨å®šä¹‰ (Global Constant Lists Definition)
	// ========================================================================

	/**
	 * ç‰¹å¾å€¼åˆ—è¡¨ï¼šå®šä¹‰æ¯ä¸ªç‰¹å¾çš„æ‰€æœ‰å¯èƒ½å€¼
	 *
	 * ä½¿ç”¨ initializer_list çš„å¥½å¤„ï¼š
	 * - å¯ä»¥åœ¨ range-based for å¾ªç¯ä¸­éå†
	 * - ç±»å‹å®‰å…¨ï¼Œç¼–è¯‘æœŸæ£€æŸ¥
	 * - å¸¸é‡å­˜å‚¨ï¼Œä¸å¯ä¿®æ”¹
	 *
	 * è¿™äº›åˆ—è¡¨ç”¨äºï¼š
	 * 1. ç”Ÿæˆæ‰€æœ‰ 81 å¼ å¡ç‰Œï¼ˆ4 å±‚åµŒå¥—å¾ªç¯ï¼‰
	 * 2. æ‰“å°æ‰€æœ‰å¯èƒ½çš„ç‰¹å¾å€¼
	 * 3. æµ‹è¯•å’ŒéªŒè¯
	 */
	std::initializer_list<Couleur> Couleurs = {Couleur::rouge, Couleur::mauve, Couleur::vert};
	std::initializer_list<Nombre> Nombres = {Nombre::un, Nombre::deux, Nombre::trois};
	std::initializer_list<Forme> Formes = {Forme::ovale, Forme::vague, Forme::losange};
	std::initializer_list<Remplissage> Remplissages = {Remplissage::plein, Remplissage::vide, Remplissage::hachure};

	string toString(Couleur c)
	{
		switch (c)
		{
		case Couleur::rouge:
			return "R";
		case Couleur::mauve:
			return "M";
		case Couleur::vert:
			return "V";
		default:
			throw SetException("Couleur inconnue");
		}
	}

	string toString(Nombre v)
	{
		switch (v)
		{
		case Nombre::un:
			return "1";
		case Nombre::deux:
			return "2";
		case Nombre::trois:
			return "3";
		default:
			throw SetException("Nombre inconnue");
		}
	}

	string toString(Forme f)
	{
		switch (f)
		{
		case Forme::ovale:
			return "O";
		case Forme::vague:
			return "~";
		case Forme::losange:
			return "\004";
		default:
			throw SetException("Forme inconnue");
		}
	}

	string toString(Remplissage r)
	{
		switch (r)
		{
		case Remplissage::plein:
			return "P";
		case Remplissage::vide:
			return "_";
		case Remplissage::hachure:
			return "H";
		default:
			throw SetException("Remplissage inconnu");
		}
	}

	std::ostream &operator<<(std::ostream &f, Couleur c)
	{
		f << toString(c);
		return f;
	}
	std::ostream &operator<<(std::ostream &f, Nombre v)
	{
		f << toString(v);
		return f;
	}
	std::ostream &operator<<(std::ostream &f, Forme x)
	{
		f << toString(x);
		return f;
	}
	std::ostream &operator<<(std::ostream &f, Remplissage r)
	{
		f << toString(r);
		return f;
	}

	void printCouleurs(std::ostream &f)
	{
		for (auto c : Couleurs)
			f << c << " ";
		f << "\n";
	}

	void printNombres(std::ostream &f)
	{
		for (auto v : Nombres)
			f << v << " ";
		f << "\n";
	}

	void printFormes(std::ostream &f)
	{
		for (auto x : Formes)
			f << x << " ";
		f << "\n";
	}

	void printRemplissages(std::ostream &f)
	{
		for (auto r : Remplissages)
			f << r << " ";
		f << "\n";
	}

	ostream &operator<<(ostream &f, const Carte &c)
	{
		f << "[" << c.getCouleur() << c.getForme()
		  << c.getNombre() << c.getRemplissage() << "]";
		return f;
	}

	Jeu::Jeu()
	{
		size_t i = 0;
		for (auto c : Couleurs)
			for (auto n : Nombres)
				for (auto f : Formes)
					for (auto r : Remplissages)
						cartes[i++] = new Carte(c, n, f, r);
	}

	const Carte &Jeu::getCarte(size_t i) const
	{
		if (i >= 81)
			throw SetException("carte iexistante");
		return *cartes[i];
	}

	Jeu::~Jeu()
	{
		for (size_t i = 0; i < 81; i++)
			delete cartes[i];
	}

	const Carte &Pioche::piocher()
	{ // get a random carte from the pioche
		// test if the pioche is not empty
		if (estVide())
			throw SetException("empty pioche");
		// choose a carte
		size_t i = rand() % nb; // get a random number between 0 and nb
		const Carte *chosenCarte = cartes[i];
		// remove the card from the array
		cartes[i] = cartes[nb - 1]; // replace carte i by the last carte of the pioche
		nb--;
		return *chosenCarte; // returns a reference over the chosen carte
	}

	/**
	 * å‘æ¸¸æˆå°æ·»åŠ ä¸€å¼ å¡ç‰Œ (Add a card to the plateau)
	 *
	 * @param c è¦æ·»åŠ çš„å¡ç‰Œçš„å¸¸é‡å¼•ç”¨
	 *
	 * å®ç°è¦ç‚¹ï¼š
	 * 1. åŠ¨æ€æ‰©å®¹æœºåˆ¶
	 *    - å½“æ•°ç»„æ»¡æ—¶ï¼Œè‡ªåŠ¨æ‰©å®¹ï¼ˆå¢åŠ  5 ä¸ªä½ç½®ï¼‰
	 *    - å°†æ—§æ•°ç»„å†…å®¹å¤åˆ¶åˆ°æ–°æ•°ç»„
	 *    - é‡Šæ”¾æ—§æ•°ç»„å†…å­˜
	 *
	 * 2. ä¸ºä»€ä¹ˆå­˜å‚¨æŒ‡é’ˆè€Œä¸æ˜¯å¯¹è±¡ï¼Ÿ
	 *    - å¡ç‰Œå¯¹è±¡ç”± Jeu ç±»ç®¡ç†ï¼ˆ81 å¼ å›ºå®šå¡ç‰Œï¼‰
	 *    - é¿å…é‡å¤åˆ›å»ºå’Œé”€æ¯å¡ç‰Œå¯¹è±¡
	 *    - èŠ‚çœå†…å­˜ï¼Œæé«˜æ€§èƒ½
	 *
	 * 3. æ‰©å®¹æ­¥é•¿ä¸ºä»€ä¹ˆæ˜¯ 5ï¼Ÿ
	 *    - å¹³è¡¡å†…å­˜ä½¿ç”¨å’Œåˆ†é…æ¬¡æ•°
	 *    - SET æ¸¸æˆé€šå¸¸æ¯æ¬¡æ·»åŠ  3 å¼ ç‰Œ
	 *    - 5 æ˜¯åˆç†çš„å°æ­¥é•¿
	 */
	void Plateau::ajouter(const Carte &c)
	{
		// æ£€æŸ¥æ•°ç»„æ˜¯å¦å·²æ»¡
		if (nb == nbMax)
		{
			// æ•°ç»„æ‰€æœ‰ä½ç½®éƒ½å·²ä½¿ç”¨ï¼Œéœ€è¦æ‰©å®¹

			// åˆ›å»ºä¸€ä¸ªæ›´å¤§çš„æ•°ç»„ï¼ˆå¢åŠ  5 ä¸ªä½ç½®ï¼‰
			const Carte **newarray = new const Carte *[nbMax + 5];

			// å°†æ‰€æœ‰å¡ç‰Œçš„åœ°å€å¤åˆ¶åˆ°æ–°æ•°ç»„
			for (size_t i = 0; i < nb; i++)
				newarray[i] = cartes[i];

			// ä¿å­˜æ—§æ•°ç»„çš„æŒ‡é’ˆä»¥ä¾¿åç»­é‡Šæ”¾
			const Carte **old = cartes;

			// å°†æ–°æ•°ç»„è®¾ç½®ä¸ºå½“å‰ä½¿ç”¨çš„æ•°ç»„
			cartes = newarray;

			// æ›´æ–°æœ€å¤§å®¹é‡
			nbMax += 5;

			// é‡Šæ”¾æ—§æ•°ç»„çš„å†…å­˜ï¼ˆæ³¨æ„ï¼šåªé‡Šæ”¾æ•°ç»„æœ¬èº«ï¼Œä¸é‡Šæ”¾å¡ç‰Œå¯¹è±¡ï¼‰
			delete[] old;
		}

		// ç°åœ¨å¯ä»¥ç¡®å®šæœ‰è¶³å¤Ÿçš„ç©ºé—´æ¥å­˜å‚¨æ›´å¤šå¡ç‰Œ
		// å°†æ–°å¡ç‰Œçš„åœ°å€å­˜å‚¨åˆ°æ•°ç»„æœ«å°¾
		cartes[nb] = &c;

		// å¢åŠ å·²å­˜å‚¨å¡ç‰Œçš„æ•°é‡
		nb++;
	}

	/**
	 * ä»æ¸¸æˆå°ç§»é™¤ä¸€å¼ å¡ç‰Œ (Remove a card from the plateau)
	 *
	 * @param c è¦ç§»é™¤çš„å¡ç‰Œçš„å¸¸é‡å¼•ç”¨
	 * @throws SetException å¦‚æœå¡ç‰Œä¸å­˜åœ¨äºæ¸¸æˆå°
	 *
	 * å®ç°ç­–ç•¥ï¼š
	 * 1. çº¿æ€§æœç´¢è¦ç§»é™¤çš„å¡ç‰Œï¼ˆæ¯”è¾ƒæŒ‡é’ˆåœ°å€ï¼‰
	 * 2. ç”¨æœ€åä¸€å¼ å¡ç‰Œæ›¿æ¢è¦ç§»é™¤çš„å¡ç‰Œï¼ˆé¿å…ç§»åŠ¨å¤§é‡å…ƒç´ ï¼‰
	 * 3. å‡å°‘å¡ç‰Œè®¡æ•°
	 *
	 * æ—¶é—´å¤æ‚åº¦ï¼šO(n) - éœ€è¦æœç´¢å¡ç‰Œ
	 * ä¼˜ç‚¹ï¼šç§»é™¤æ“ä½œæœ¬èº«æ˜¯ O(1)
	 * ç¼ºç‚¹ï¼šä¸ä¿æŒå¡ç‰Œé¡ºåºï¼ˆä½† SET æ¸¸æˆä¸éœ€è¦ä¿æŒé¡ºåºï¼‰
	 */
	void Plateau::retirer(const Carte &c)
	{
		// åœ¨æ•°ç»„ä¸­æœç´¢è¦ç§»é™¤çš„å¡ç‰Œ
		size_t i = 0;
		while (i < nb && cartes[i] != &c) // æ¯”è¾ƒæŒ‡é’ˆåœ°å€
			i++;

		// å¦‚æœéå†å®Œæ•´ä¸ªæ•°ç»„éƒ½æ²¡æ‰¾åˆ°ï¼Œè¯´æ˜å¡ç‰Œä¸å­˜åœ¨
		if (i == nb)
			throw SetException("this card does not exist");

		// ç”¨æœ€åä¸€å¼ å¡ç‰Œæ›¿æ¢è¦ç§»é™¤çš„å¡ç‰Œï¼ˆé«˜æ•ˆçš„ç§»é™¤æ–¹æ³•ï¼‰
		cartes[i] = cartes[nb - 1];

		// å‡å°‘å¡ç‰Œè®¡æ•°ï¼ˆåŸæ¥çš„æœ€åä¸€å¼ å¡ç‰Œç°åœ¨ä¸å†æœ‰æ•ˆï¼‰
		nb--;
	}

	/**
	 * æ‹·è´æ„é€ å‡½æ•° (Copy Constructor)
	 *
	 * @param p è¦æ‹·è´çš„æº Plateau å¯¹è±¡
	 *
	 * ä¸ºä»€ä¹ˆéœ€è¦è‡ªå®šä¹‰æ‹·è´æ„é€ å‡½æ•°ï¼Ÿ
	 * =====================================
	 * å¦‚æœä½¿ç”¨é»˜è®¤æ‹·è´æ„é€ å‡½æ•°ï¼ˆç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆï¼‰ï¼š
	 * - ä¼šæ‰§è¡Œæµ…æ‹·è´ï¼šåªå¤åˆ¶æŒ‡é’ˆ cartes çš„å€¼
	 * - ç»“æœï¼šä¸¤ä¸ª Plateau å¯¹è±¡çš„ cartes æŒ‡å‘åŒä¸€ä¸ªæ•°ç»„
	 * - é—®é¢˜ï¼šä¿®æ”¹ä¸€ä¸ªå¯¹è±¡ä¼šå½±å“å¦ä¸€ä¸ªå¯¹è±¡
	 * - æ›´ä¸¥é‡ï¼šææ„æ—¶ä¼šå¯¼è‡´åŒé‡é‡Šæ”¾ï¼ˆdouble freeï¼‰é”™è¯¯
	 *
	 * æ·±æ‹·è´å®ç°ï¼š
	 * ===========
	 * 1. ä¸ºæ–°å¯¹è±¡åˆ†é…ç‹¬ç«‹çš„æ•°ç»„
	 * 2. å¤åˆ¶æ‰€æœ‰å¡ç‰ŒæŒ‡é’ˆï¼ˆæ³¨æ„ï¼šå¤åˆ¶çš„æ˜¯æŒ‡é’ˆï¼Œä¸æ˜¯å¡ç‰Œå¯¹è±¡ï¼‰
	 * 3. å¤åˆ¶å®¹é‡å’Œå¤§å°ä¿¡æ¯
	 *
	 * ç»“æœï¼šæ¯ä¸ª Plateau æœ‰è‡ªå·±çš„æ•°ç»„ï¼Œä½†æŒ‡å‘ç›¸åŒçš„å¡ç‰Œå¯¹è±¡
	 */
	Plateau::Plateau(const Plateau &p)
	{
		// ä¸ºæ–° Plateau åˆ†é…ç‹¬ç«‹çš„æ•°ç»„ï¼ˆæ·±æ‹·è´ï¼‰
		cartes = new const Carte *[p.nbMax];

		// å¤åˆ¶æºå¯¹è±¡çš„å®¹é‡å’Œå¤§å°ä¿¡æ¯
		nb = p.nb;
		nbMax = p.nbMax;

		// å¤åˆ¶æ‰€æœ‰å¡ç‰ŒæŒ‡é’ˆ
		for (size_t i = 0; i < p.nb; i++)
			cartes[i] = p.cartes[i];

		// ç°åœ¨æ¯ä¸ª Plateau éƒ½æœ‰è‡ªå·±çš„æ•°ç»„ï¼Œä½†åŒ…å«ç›¸åŒçš„å¡ç‰Œ
	}

	/**
	 * èµ‹å€¼è¿ç®—ç¬¦é‡è½½ (Assignment Operator)
	 *
	 * @param p è¦èµ‹å€¼çš„æº Plateau å¯¹è±¡
	 * @return è¿”å›å½“å‰å¯¹è±¡çš„å¼•ç”¨ï¼ˆæ”¯æŒé“¾å¼èµ‹å€¼ï¼‰
	 *
	 * å®ç°è¦ç‚¹ï¼š
	 * =========
	 * 1. è‡ªèµ‹å€¼æ£€æŸ¥ï¼šif (this != &p)
	 *    - é˜²æ­¢ a = a è¿™æ ·çš„æ“ä½œå¯¼è‡´é—®é¢˜
	 *    - æé«˜æ€§èƒ½ï¼ˆé¿å…ä¸å¿…è¦çš„æ“ä½œï¼‰
	 *
	 * 2. èµ‹å€¼ç­–ç•¥ï¼š
	 *    - æ¸…ç©ºå½“å‰ Plateauï¼ˆè®¾ç½® nb = 0ï¼‰
	 *    - ä¿ç•™ç°æœ‰æ•°ç»„å®¹é‡ï¼ˆé¿å…é‡æ–°åˆ†é…ï¼‰
	 *    - ä½¿ç”¨ ajouter() é€ä¸ªæ·»åŠ å¡ç‰Œ
	 *    - ajouter() ä¼šåœ¨éœ€è¦æ—¶è‡ªåŠ¨æ‰©å®¹
	 *
	 * 3. ä¸ºä»€ä¹ˆä¸ç›´æ¥å¤åˆ¶æ•°ç»„ï¼Ÿ
	 *    - åˆ©ç”¨ç°æœ‰çš„ ajouter() é€»è¾‘
	 *    - è‡ªåŠ¨å¤„ç†æ‰©å®¹
	 *    - ä»£ç å¤ç”¨ï¼Œå‡å°‘é”™è¯¯
	 *
	 * 4. è¿”å› *this çš„ä½œç”¨ï¼š
	 *    - æ”¯æŒé“¾å¼èµ‹å€¼ï¼ša = b = c
	 *    - ç¬¦åˆ C++ èµ‹å€¼è¿ç®—ç¬¦çš„æƒ¯ä¾‹
	 */
	Plateau &Plateau::operator=(const Plateau &p)
	{
		// æ£€æŸ¥æ˜¯å¦ä¸ºè‡ªèµ‹å€¼ï¼ˆa = aï¼‰
		if (this != &p)
		{
			// æ³¨æ„ï¼šæ­¤æ—¶ *this å’Œ p éƒ½æœ‰å„è‡ªçš„æ•°ç»„

			// æ¸…ç©ºå½“å‰æ•°ç»„ï¼ˆä½†ä¿ç•™å®¹é‡ï¼‰
			nb = 0;
			// æˆ‘ä»¬è®¤ä¸ºæ•°ç»„ä¸­ä¸å†æœ‰å¡ç‰Œ
			// ä½†ä¿ç•™æ•°ç»„çš„å®¹é‡ï¼Œå¯ä»¥ç»§ç»­å­˜å‚¨æ–°çš„æŒ‡é’ˆ

			// ä»æºå¯¹è±¡å¤åˆ¶æ‰€æœ‰å¡ç‰Œ
			for (size_t i = 0; i < p.nb; i++)
				ajouter(*p.cartes[i]); // æ·»åŠ  p ä¸­çš„æ¯å¼ å¡ç‰Œ
									   // å¦‚æœéœ€è¦ï¼Œajouter ä¼šè‡ªåŠ¨æ‰©å®¹
		}

		// è¿”å›å½“å‰å¯¹è±¡çš„å¼•ç”¨ï¼ˆæ”¯æŒé“¾å¼èµ‹å€¼ï¼‰
		return *this;
	}

	/**
	 * åˆ¤æ–­ä¸‰å¼ å¡ç‰Œæ˜¯å¦æ„æˆä¸€ä¸ª SET (Check if three cards form a SET)
	 *
	 * @return true å¦‚æœä¸‰å¼ å¡ç‰Œæ„æˆ SETï¼Œfalse å¦åˆ™
	 *
	 * SET æ¸¸æˆè§„åˆ™ï¼š
	 * =============
	 * ä¸‰å¼ å¡ç‰Œæ„æˆä¸€ä¸ª SET å½“ä¸”ä»…å½“ï¼š
	 * å¯¹äºæ¯ä¸ªç‰¹å¾ï¼ˆé¢œè‰²ã€å½¢çŠ¶ã€æ•°é‡ã€å¡«å……ï¼‰ï¼Œè¿™ä¸‰å¼ å¡ç‰Œè¦ä¹ˆï¼š
	 * - å®Œå…¨ç›¸åŒï¼ˆ3 å¼ éƒ½ä¸€æ ·ï¼‰
	 * - å®Œå…¨ä¸åŒï¼ˆ3 å¼ éƒ½ä¸ä¸€æ ·ï¼‰
	 *
	 * ç¤ºä¾‹ï¼š
	 * ------
	 * âœ“ åˆæ³• SETï¼š[Râ—‡1P] [Mâ—‡2P] [Vâ—‡3P]
	 *   - é¢œè‰²ï¼šR, M, Vï¼ˆå…¨ä¸åŒï¼‰âœ“
	 *   - å½¢çŠ¶ï¼šâ—‡, â—‡, â—‡ï¼ˆå…¨ç›¸åŒï¼‰âœ“
	 *   - æ•°é‡ï¼š1, 2, 3ï¼ˆå…¨ä¸åŒï¼‰âœ“
	 *   - å¡«å……ï¼šP, P, Pï¼ˆå…¨ç›¸åŒï¼‰âœ“
	 *
	 * âœ— éæ³•ç»„åˆï¼š[Râ—‡1P] [Râ—‡2P] [Vâ—‡3P]
	 *   - é¢œè‰²ï¼šR, R, Vï¼ˆä¸¤åŒä¸€å¼‚ï¼‰âœ—
	 *
	 * å®ç°é€»è¾‘ï¼š
	 * =========
	 * å¯¹äºæ¯ä¸ªç‰¹å¾ï¼Œæ£€æŸ¥ï¼š
	 * - æ¡ä»¶1ï¼šc1 == c2 && c1 == c3  ï¼ˆå…¨ç›¸åŒï¼‰
	 * - æ¡ä»¶2ï¼šc1 != c2 && c1 != c3 && c2 != c3  ï¼ˆå…¨ä¸åŒï¼‰
	 *
	 * åŸå…ˆä»£ç ä¸­å¥½åƒæœ€åä¸€ä¸ªå†™é”™äº†
	 * å½“å‰æ¡ä»¶2å†™çš„æ˜¯ï¼šc1 != c2 && c1 != c3 && c2 == c3
	 * è¿™å®é™…ä¸Šå…è®¸"ä¸¤åŒä¸€å¼‚"çš„æƒ…å†µï¼Œè¿åäº† SET è§„åˆ™
	 * æ­£ç¡®çš„åº”è¯¥æ˜¯ï¼šc1 != c2 && c1 != c3 && c2 != c3
	 */
	bool Combinaison::estUnSet() const
	{
		// æµ‹è¯•é¢œè‰²ï¼šå…¨ç›¸åŒ æˆ– å…¨ä¸åŒ
		// âš ï¸ BUGï¼šç¬¬äºŒä¸ªæ¡ä»¶å…è®¸ c2 == c3ï¼Œåº”è¯¥æ˜¯ä¸‰è€…éƒ½ä¸åŒ
		bool test1 = (c1->getCouleur() == c2->getCouleur() && c1->getCouleur() == c3->getCouleur()) ||
					 (c1->getCouleur() != c2->getCouleur() && c1->getCouleur() != c3->getCouleur() && c2->getCouleur() != c3->getCouleur());

		// æµ‹è¯•å½¢çŠ¶ï¼šå…¨ç›¸åŒ æˆ– å…¨ä¸åŒ
		bool test2 = (c1->getForme() == c2->getForme() && c1->getForme() == c3->getForme()) ||
					 (c1->getForme() != c2->getForme() && c1->getForme() != c3->getForme() && c2->getForme() != c3->getForme());

		// æµ‹è¯•æ•°é‡ï¼šå…¨ç›¸åŒ æˆ– å…¨ä¸åŒ
		bool test3 = (c1->getNombre() == c2->getNombre() && c1->getNombre() == c3->getNombre()) ||
					 (c1->getNombre() != c2->getNombre() && c1->getNombre() != c3->getNombre() && c2->getNombre() != c3->getNombre());

		// æµ‹è¯•å¡«å……ï¼šå…¨ç›¸åŒ æˆ– å…¨ä¸åŒ
		bool test4 = (c1->getRemplissage() == c2->getRemplissage() && c1->getRemplissage() == c3->getRemplissage()) ||
					 (c1->getRemplissage() != c2->getRemplissage() && c1->getRemplissage() != c3->getRemplissage() && c2->getRemplissage() != c3->getRemplissage());

		// æ‰€æœ‰å››ä¸ªç‰¹å¾éƒ½å¿…é¡»æ»¡è¶³è§„åˆ™
		return test1 && test2 && test3 && test4;
	}

	/**
	 * ä»ç‰Œå †å‘æ¸¸æˆå°åˆ†å‘å¡ç‰Œ (Distribute cards from pioche to plateau)
	}

	/**
	 * ä»ç‰Œå †å‘æ¸¸æˆå°åˆ†å‘å¡ç‰Œ (Distribute cards from pioche to plateau)
	 *
	 * åˆ†å‘è§„åˆ™ï¼š
	 * =========
	 * 1. å¦‚æœæ¸¸æˆå°å°‘äº 12 å¼ ç‰Œï¼š
	 *    - å°è¯•è¡¥é½åˆ° 12 å¼ 
	 *    - ä»ç‰Œå †æŠ½å–å¡ç‰Œï¼Œç›´åˆ°è¾¾åˆ° 12 å¼ æˆ–ç‰Œå †ä¸ºç©º
	 *
	 * 2. å¦‚æœæ¸¸æˆå°å·²æœ‰ 12 å¼ æˆ–æ›´å¤šç‰Œï¼š
	 *    - åªæ·»åŠ  1 å¼ ç‰Œ
	 *    - ç”¨äºç©å®¶æ‰¾ä¸åˆ° SET æ—¶å¢åŠ é€‰æ‹©
	 *
	 * 3. å¦‚æœç‰Œå †ä¸ºç©ºï¼š
	 *    - ä»€ä¹ˆéƒ½ä¸åš
	 *    - æ¸¸æˆå¯èƒ½å³å°†ç»“æŸ
	 *
	 * å®ç°ç»†èŠ‚ï¼š
	 * =========
	 * - å…ˆæ·»åŠ ä¸€å¼ ç‰Œï¼ˆç¡®ä¿è‡³å°‘å°è¯•æ·»åŠ ä¸€æ¬¡ï¼‰
	 * - ç„¶åæ£€æŸ¥æ˜¯å¦éœ€è¦ç»§ç»­è¡¥å……ï¼ˆå°‘äº 12 å¼ ï¼‰
	 * - ä½¿ç”¨ while å¾ªç¯æŒç»­æŠ½ç‰Œï¼Œç›´åˆ°è¾¾åˆ°æ¡ä»¶
	 *
	 * ä¸ºä»€ä¹ˆæ˜¯ 12 å¼ ï¼Ÿ
	 * ==============
	 * - SET æ¸¸æˆæ ‡å‡†è§„åˆ™ï¼šæ¸¸æˆå°åº”å§‹ç»ˆæœ‰ 12 å¼ ç‰Œ
	 * - 12 = 3Ã—4ï¼Œä¾¿äºè§†è§‰å¸ƒå±€ï¼ˆ3 è¡Œ 4 åˆ—æˆ– 4 è¡Œ 3 åˆ—ï¼‰
	 * - ç»Ÿè®¡ä¸Šï¼Œ12 å¼ ç‰Œä¸­å­˜åœ¨ SET çš„æ¦‚ç‡å¾ˆé«˜
	 */
	void Controleur::distribuer()
	{
		// å¦‚æœç‰Œå †ä¸ä¸ºç©ºï¼Œå…ˆæ·»åŠ ä¸€å¼ ç‰Œ
		if (!pioche->estVide())
			plateau.ajouter(pioche->piocher());

		// å¦‚æœæ¸¸æˆå°å°‘äº 12 å¼ ç‰Œï¼Œç»§ç»­è¡¥å……
		while (!pioche->estVide() && plateau.getNbCartes() < 12)
			plateau.ajouter(pioche->piocher());
	}

	/**
	 * Combinaison ç±»çš„è¾“å‡ºè¿ç®—ç¬¦é‡è½½ (Output operator for Combinaison)
	 *
	 * @param f è¾“å‡ºæµå¯¹è±¡ï¼ˆå¦‚ cout, ofstream ç­‰ï¼‰
	 * @param c è¦è¾“å‡ºçš„ç»„åˆå¯¹è±¡
	 * @return è¿”å›è¾“å‡ºæµå¯¹è±¡ï¼ˆæ”¯æŒé“¾å¼è¾“å‡ºï¼‰
	 *
	 * è¾“å‡ºæ ¼å¼ï¼š[å¡ç‰Œ1 ; å¡ç‰Œ2 ; å¡ç‰Œ3]
	 * ç¤ºä¾‹ï¼š[[Râ—‡1P] ; [Mâ—‡2P] ; [Vâ—‡3P]]
	 */
	ostream &operator<<(ostream &f, const Combinaison &c)
	{
		f << "[" << c.getCarte1() << " ; " << c.getCarte2() << " ; " << c.getCarte3() << "]";
		return f;
	}

	/**
	 * æ‰“å°æ¸¸æˆå°çš„æ‰€æœ‰å¡ç‰Œ (Print all cards on the plateau)
	 *
	 * @param f è¾“å‡ºæµå¯¹è±¡
	 *
	 * æ˜¾ç¤ºæ ¼å¼ï¼š
	 * =================== PLATEAU ===================
	 * [å¡ç‰Œ1][å¡ç‰Œ2][å¡ç‰Œ3]
	 * [å¡ç‰Œ4][å¡ç‰Œ5][å¡ç‰Œ6]
	 * ...
	 * ===============================================
	 *
	 * å¸ƒå±€è§„åˆ™ï¼š
	 * - æ¯ 3 å¼ å¡ç‰Œæ¢è¡Œ
	 * - ä¾¿äºç©å®¶è§‚å¯Ÿå’Œå¯»æ‰¾ SET
	 * - ä¸Šä¸‹è£…é¥°çº¿ä½¿è¾“å‡ºæ›´æ¸…æ™°
	 */
	void Plateau::print(ostream &f) const
	{
		f << "=================== PLATEAU ===================\n";

		// éå†å¹¶æ‰“å°æ‰€æœ‰å¡ç‰Œ
		for (size_t i = 0; i < nb; i++)
		{
			// æ¯ 3 å¼ å¡ç‰Œæ¢è¡Œï¼ˆåˆ›å»ºç±»ä¼¼ç½‘æ ¼çš„å¸ƒå±€ï¼‰
			if (i % 3 == 0)
				f << "\n";

			// æ‰“å°å¡ç‰Œï¼ˆè‡ªåŠ¨è°ƒç”¨ Carte çš„ operator<<ï¼‰
			f << *cartes[i];
		}

		f << "\n===============================================\n";
	}

	/**
	 * Plateau ç±»çš„è¾“å‡ºè¿ç®—ç¬¦é‡è½½ (Output operator for Plateau)
	 *
	 * @param f è¾“å‡ºæµå¯¹è±¡
	 * @param c Plateau å¯¹è±¡
	 * @return è¿”å›è¾“å‡ºæµå¯¹è±¡ï¼ˆæ”¯æŒé“¾å¼è¾“å‡ºï¼‰
	 *
	 * å§”æ‰˜ç»™ print() æ–¹æ³•å®ç°
	 * ä½¿ç”¨æ–¹æ³•ï¼šcout << plateau;
	 */
	ostream &operator<<(ostream &f, const Plateau &c)
	{
		c.print(f);
		return f;
	}

}
```


# Ex23
```cpp
/*
è¦æ±‚å®ç°å•ä¾‹æ¨¡å¼å’Œè¿­ä»£å™¨æ¨¡å¼
è¯¦æƒ…è¯·çœ‹ Ex22&23 æ–‡ä»¶å¤¹ä¸­çš„ const_iterator ç±»
*/```

