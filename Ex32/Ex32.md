当通过 基类指针或引用 访问对象时
- 如果只使用 基类中声明的接口（上层能力），那么这是向上转型，永远安全不需要任何检查
- 如果希望使用 派生类特有的能力 ，那么是向下转型，必须通过 dynamic_cast 在运行时检查对象的真实类型


# Q1
错误点：
1. 直接把Evt1j* 当成Rdv*
```
Rdv* pt = pt1;      pt->afficher();
pt = pt2;           pt->afficher();
pt = pt3;           pt->afficher();
pt = pt4;           pt->afficher();
```
pt1, pt2, pt3, pt4 的静态类型都是 Evt1j*，只有 pt4 实际指向 Rdv 对象
将他们都当作 Rdv* 属于向下转型，只有当真实类型确实是 Rdv 时才成立
正确需要用 dynamic_cast 做运行时检查
dynamic_cast<baseClass*>(basePtr)
    成功时返回非空指针
    失败返回 nullptr
```
Rdv* pt = dynamic_cast<Rdv*>(pt1);
if (pt) pt->afficher(); else std::cout << "pt1 n'est pas un Rdv\n";
```

2. 直接把Evt1j& 当作Rdv&
```
Rdv& r1 = ref1;     r1.afficher();
Rdv& r2 = ref2;     r2.afficher();
Rdv& r3 = ref3;     r3.afficher();
Rdv& r4 = ref4;     r4.afficher();
```
这是引用的 down-cast。引用没有 “null”，所以失败时不会给你返回空，而是：
    抛异常 std::bad_cast
正确做法是 dynamic_cast<baseClass&> 并 catch(const std::bad_cast&)捕获异常
```
try {
    Rdv& r = dynamic_cast<Rdv&>(ref1);
    r.afficher();
} catch(const std::bad_cast&) {
    std::cout << "ref1 n'est pas un Rdv\n";
}
```

# Q2
1. Up-casting 向上转型
```
Rdv* p = new Rdv(...);
Evt1j* b = p;  // ✅ 永远安全
```
因为 Rdv 一定是 Evt1j(is-a) 不需要运行时检查

2. Down-casting 向下转型
```
Evt1j* b = &e1;  // e1 是 Evt1j
Rdv* p = (Rdv*)b; // ❌ 危险
```
正确：得需要 dynamic_cast 安全检查
```
Rdv* p = dynamic_cast<Rdv*>(b); // ✅ 安全检查
```