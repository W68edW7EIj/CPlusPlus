虽然对象的真实类型在创建时已经确定、不可改变
但是上层类的指针或引用，在运行期间可以指向一个本来就是下层类创建的对象；
通过 dynamic_cast 可以在运行时确认该对象是否确实属于该下层类型

当通过 上层基类指针或引用 访问对象时
- 如果只使用 基类中声明的接口（上层能力），那么这是向上转型，编译期 就知道永远安全不需要任何检查
```
Rdv* p = new Rdv;
Evt1j* b = p;        // up-cast
b->afficher();       // 调用基类接口（多态）
```
- 如果希望使用 派生类特有的能力 ，那么是向下转型，必须通过 dynamic_cast 在 运行期 检查对象的真实类型
```
Evt1j* p = new Rdv;
dynamic_cast<Rdv*>(p)->getLieu();
```


# Q1
错误点：
1. 直接把Evt1j* 当成Rdv*
```
Rdv* pt = pt1;      pt->afficher();
pt = pt2;           pt->afficher();
pt = pt3;           pt->afficher();
pt = pt4;           pt->afficher();
```
pt1, pt2, pt3, pt4 的静态类型都是 Evt1j*，只有 pt4 实际指向 Rdv 对象
将他们都当作 Rdv* 属于向下转型，只有当真实类型确实是 Rdv 时才成立
正确需要用 dynamic_cast 做运行时检查
dynamic_cast<baseClass*>(basePtr)
    成功时返回非空指针
    失败返回 nullptr
```
Rdv* pt = dynamic_cast<Rdv*>(pt1);
if (pt) pt->afficher(); else std::cout << "pt1 n'est pas un Rdv\n";
```

2. 直接把Evt1j& 当作Rdv&
```
Rdv& r1 = ref1;     r1.afficher();
Rdv& r2 = ref2;     r2.afficher();
Rdv& r3 = ref3;     r3.afficher();
Rdv& r4 = ref4;     r4.afficher();
```
这是引用的 down-cast。引用没有 “null”，所以失败时不会给你返回空，而是：
    抛异常 std::bad_cast
正确做法是 dynamic_cast<baseClass&> 并 catch(const std::bad_cast&)捕获异常
```
try {
    Rdv& r = dynamic_cast<Rdv&>(ref1);
    r.afficher();
} catch(const std::bad_cast&) {
    std::cout << "ref1 n'est pas un Rdv\n";
}
```

# Q2
1. Up-casting 向上转型
```
Rdv* p = new Rdv(...);
Evt1j* b = p;  // ✅ 永远安全
```
因为 Rdv 一定是 Evt1j(is-a) 不需要运行时检查

2. Down-casting 向下转型
```
Evt1j* b = &e1;  // e1 是 Evt1j
Rdv* p = (Rdv*)b; // ❌ 危险
```
正确：得需要 dynamic_cast 安全检查
```
Rdv* p = dynamic_cast<Rdv*>(b); // ✅ 安全检查
```